### collect_sequenza_output.R ######################################################################
# Finds and combines output generated by Sequenza (CN segments, cellularity, ploidy)

### FUNCTIONS ######################################################################################
# function to generate a standardized filename
generate.filename <- function(project.stem, file.core, extension, include.date = TRUE) {

	# build up the filename
	file.name <- paste(project.stem, file.core, sep = '_');
	file.name <- paste(file.name, extension, sep = '.');

	if (include.date) {
		file.name <- paste(Sys.Date(), file.name, sep = '_');
		}

	return(file.name);
	}

# function to write session profile to file
save.session.profile <- function(file.name) {

	# open the file
	sink(file = file.name, split = FALSE);

	# write memory usage to file
	cat('### MEMORY USAGE ###############################################################');
	print(proc.time());

	# write sessionInfo to file
	cat("\n### SESSION INFO ###############################################################");
	print(sessionInfo());

	# close the file
	sink();

	}

# function to fill gaps (provided by jbruce)
fillgaps <- function(seg) {
  
	for (i in 1:(nrow(seg)-1)) {

		chr <- as.character(seg[i,]$chromosome);
		start <- seg[i,]$start.pos;
		end <- seg[i,]$end.pos;

		if (seg[i+1,"chromosome"] == chr & seg[i+1,"start.pos"] != (end + 1)) {

      			if (abs(seg[i,"CNt"]) > abs(seg[i+1,"CNt"])) {
				seg[i,"end.pos"] <- seg[i+1,"start.pos"]-1;
				} else {
				seg[i+1,"start.pos"] <- seg[i,"end.pos"]+1;
				}
			}
		}

	return(seg);
	}

# function to get ploidy-adjusted absolute CN value (as per JB)
get.ploidyadjusted.cn <- function(cn, ploidy) {
	 ifelse(
		# if ploidy is high AND CN is high, indicate amplification
		ploidy > 2 & (cn - round(ploidy)) >= 2, 2,
		# or, if ploidy is low/diploid AND CN is high, indicate amplification
		ifelse(
			ploidy <= 2 & (cn - 2) >= 2, 2,
			ifelse(
				# regardless, if CN == 0, this is homozygous deletion
				cn == 0, -2,
				ifelse(
					# if ploidy-adjusted CN is > 0, inidate gain
					(cn - round(ploidy)) >= 1, 1,
					ifelse(
						# if ploidy-adjusted CN is < 0, indicate loss
						# anything left is neutral
						(cn - round(ploidy)) <= -1, -1, 0
						)
					)
				)
			)
		);
	}

### PREPARE SESSION ################################################################################
# import libraries
library(GenomicRanges);
library(org.Hs.eg.db);
library(argparse);

# import command line arguments
parser <- ArgumentParser();

parser$add_argument('-d', '--directory', type = 'character', help = 'path to data directory');
parser$add_argument('-p', '--project', type = 'character', help = 'project name');
parser$add_argument('-r', '--ref_type', type = 'character', help = 'reference type', default = 'hg38');
parser$add_argument('-t', '--targets', type = 'character', help = 'target intervals');

arguments <- parser$parse_args();

# what's the date?
date <- Sys.Date();

setwd(arguments$directory);

### FORMAT ANNOTATION ##############################################################################
if (arguments$ref_type %in% c('hg38','GRCh38')) {
	library(TxDb.Hsapiens.UCSC.hg38.knownGene);
	txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene;
	} else if (arguments$ref_type %in% c('hg19','GRCh37')) {
	library(TxDb.Hsapiens.UCSC.hg19.knownGene);
	txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene;
	}
 
# organize all transcripts by GeneID
txdb_table <- transcriptsBy(txdb, by = 'gene');

# extract GeneIDs
tx_ids <- names(txdb_table);

# extract 
transcript_table <- select(
	TxDb.Hsapiens.UCSC.hg38.knownGene,
	keys = tx_ids,
	columns = c('GENEID','TXNAME','TXCHROM','TXSTART','TXEND'),
	keytype = 'GENEID'
	);
colnames(transcript_table)[1] <- 'ENTREZID';

# pull in extra annotations
transcript_table$SYMBOL <- mapIds(
	org.Hs.eg.db,
	keys = transcript_table$TXNAME,
	keytype = 'UCSCKG',
	column = 'SYMBOL'
	);

transcript_table$ENSEMBL <- mapIds(
	org.Hs.eg.db,
	keys = transcript_table$TXNAME,
	keytype = 'UCSCKG',
	column = 'ENSEMBL'
	);

transcript_table$MAP <- mapIds(
	org.Hs.eg.db,
	keys = transcript_table$TXNAME,
	keytype = 'UCSCKG',
	column = 'MAP'
	);

transcript_table$GENETYPE <- mapIds(
	org.Hs.eg.db,
	keys = transcript_table$TXNAME,
	keytype = 'UCSCKG',
	column = 'GENETYPE'
	);

# remove unmatching cases
transcript_table$MAPCHROM <- sapply(
	transcript_table$MAP,
	function(i) { paste0('chr', unlist(strsplit(i, 'p|q'))[1]) }
	);

transcript_table <- transcript_table[which(transcript_table$TXCHROM == transcript_table$MAPCHROM),];

# squish it to 1 entry per gene
gene.annotation <- merge(
	aggregate(TXSTART ~ ENTREZID + SYMBOL + ENSEMBL + GENETYPE + TXCHROM, transcript_table, min),
	aggregate(TXEND ~ ENTREZID + SYMBOL + ENSEMBL + GENETYPE + TXCHROM, transcript_table, max),
	);
colnames(gene.annotation)[5:7] <- c('Chromosome','Start','End');
gene.annotation$Chromosome <- factor(gene.annotation$Chromosome, levels = paste0('chr',c(1:22,'X','Y')));
gene.annotation <- gene.annotation[order(gene.annotation$Chromosome, gene.annotation$Start),];

gene.gr <- GRanges(gene.annotation);

# if provided, filter to target intervals
gene.annotation$Target <- NA;
if (!is.null(arguments$targets)) {

	target.intervals <- read.delim(arguments$targets, header = F, comment.char = '#');
	colnames(target.intervals)[1:3] <- c('Chromosome','Start','End');

	target.gr <- GRanges(target.intervals);

	overlaps <- as.data.frame(findOverlaps(gene.gr, target.gr));

	gene.annotation$Target <- 0;
	gene.annotation[unique(overlaps$queryHits),]$Target <- 1;
	}

### MAIN ###########################################################################################
# find results files
ploidy.files <- list.files(pattern = 'alternative_solutions.txt$', recursive = TRUE);
seg.files <- list.files(pattern = 'segments.txt$', recursive = TRUE);

ploidy.files <- ploidy.files[grepl('optimized', ploidy.files)];
seg.files <- seg.files[grepl('optimized', seg.files)];

ploidy.files <- ploidy.files[!grepl('output_udp|/sol', ploidy.files)];
seg.files <- seg.files[!grepl('output_udp|/sol', seg.files)];

# read them in
ploidy.list <- list();

for (file in ploidy.files) {
	# extract sample ID
	smp <- unlist(strsplit(basename(file), '_VarScan'))[1];
	# store data in list
	if (smp %in% names(ploidy.list)) { next; }
	ploidy.list[[smp]] <- read.delim(file);
	}

# format ploidy/cellularity results
ploidy.data <- do.call(rbind, ploidy.list);
ploidy.data$Sample <- sapply(rownames(ploidy.data), function(i) { unlist(strsplit(as.character(i),'\\.'))[1] } );
ploidy.data$Order <- sapply(rownames(ploidy.data), function(i) { unlist(strsplit(as.character(i),'\\.'))[2] } );
if (any(is.na(ploidy.data$Order))) {
	ploidy.data[is.na(ploidy.data$Order),]$Order <- 1;
	}

# combine for writing
ploidy.formatted <- ploidy.data[which(ploidy.data$Order == 1),c('Sample','SLPP','cellularity','ploidy')];

# add field for PGA (to be filled in later)
ploidy.formatted$PGA <- NA;

# and for segments
seg.list <- list();

for (file in seg.files) {
	# extract sample ID
	smp <- unlist(strsplit(basename(file), '_VarScan'))[1];

	# store data in list
	if (smp %in% names(seg.list)) { next; }
	segs <- read.delim(file);
	segs <- fillgaps(segs[!is.na(segs$CNt),]);
	seg.list[[smp]] <- segs;
	}

# format segments for gistic
# https://crazyhottommy.blogspot.com/2017/11/run-gistic2-with-sequenza-segmentation.html
segment.data <- do.call(rbind, seg.list);
segment.data$Sample <- sapply(rownames(segment.data), function(i) { unlist(strsplit(i,'\\.'))[1] } );
segment.data$Seg.CN <- (log2(2*segment.data$depth.ratio)-1); # same as log2(depth.ratio)

write.table(
	segment.data[,c(14,1:13)],
	file = generate.filename(arguments$project, 'Sequenza_segments', 'tsv'),
	row.names = FALSE,
	col.names = TRUE,
	sep = '\t',
	quote = FALSE
	);

write.table(
	segment.data[,c('Sample','chromosome','start.pos','end.pos','N.BAF','Seg.CN')],
	file = generate.filename(arguments$project, 'segments_for_gistic', 'seg'),
	row.names = FALSE,
	col.names = TRUE,
	sep = '\t',
	quote = FALSE
	);

markers <- unique(data.frame(
	chr = rep(segment.data$chromosome, times = 2),
	pos = c(segment.data$start.pos, segment.data$end.pos)
	));

markers$chr <- factor(markers$chr, levels = paste0('chr',c(1:22,'X','Y')));
markers <- markers[order(markers$chr, -markers$pos),];
rownames(markers) <- 1:nrow(markers);

write.table(
	markers,
	file = generate.filename(arguments$project, 'markers_for_gistic','txt'),
	row.names = TRUE,
	col.names = FALSE,
	sep = '\t',
	quote = FALSE
	);

# format for cBioportal
segment.data$chromosome <- gsub('chr','',segment.data$chromosome);
segment.data <- segment.data[,c('Sample','chromosome','start.pos','end.pos','N.ratio','Seg.CN')];
colnames(segment.data) <- c('ID','chrom','loc.start','loc.end','num.mark','seg.mean');

write.table(
	segment.data,
	file = generate.filename(arguments$project, 'segments_for_cbioportal', 'seg'),
	row.names = FALSE,
	col.names = TRUE,
	sep = '\t',
	quote = FALSE
	);

# format gene tables; ploidy-adjusted AbsCN and ratio files
gene.data.cn <- gene.annotation;
gene.data.cn[,names(seg.list)] <- 0;
gene.data.ratio <- gene.data.cn;

for (smp in names(seg.list)) {

	# convert to GRanges
	tmp <- seg.list[[smp]][,c('chromosome','start.pos','end.pos','CNt','depth.ratio')];
	colnames(tmp) <- c('chrom','start','end','CN','depth.ratio');

	ploidy <- round(ploidy.formatted[which(ploidy.formatted$Sample == smp),]$ploidy);

	tmp$RATIO <- log2(tmp$depth.ratio);
	tmp$AbsCN <- get.ploidyadjusted.cn(tmp$CN, ploidy);
#	tmp$AbsCN <- log2(tmp$CN / ploidy);
#	if (any(tmp$CN == 0)) {	tmp[which(tmp$CN == 0),]$AbsCN <- -2; }

	if (nrow(tmp) == 0) { next; }
	rownames(tmp) <- paste0('seg', 1:nrow(tmp));

	# calculate PGA
	for.pga <- tmp[which(tmp$AbsCN > 0),];
	pga <- sum(for.pga$end - for.pga$start)/(3*10**9)*100;
	ploidy.formatted[which(ploidy.formatted$Sample == smp),]$PGA <- pga;

	# extract gene data
	seg.gr <- GRanges(tmp);

	# find overlap with genes (any amount of overlap)
	overlapGenes <- as.data.frame(findOverlaps(seg.gr, gene.gr, minoverlap = 20));
	regionsWithHits <- as.data.frame(seg.gr[unique(overlapGenes$queryHits)]);

	for (i in rownames(regionsWithHits)) {
		genes <- gene.gr[overlapGenes[which(overlapGenes$queryHits == sub('seg','',i)),]$subjectHits,]$SYMBOL;
		gene.data.cn[which(gene.data.cn$SYMBOL %in% genes),smp] <- tmp[i,]$AbsCN;
		gene.data.ratio[which(gene.data.ratio$SYMBOL %in% genes),smp] <- tmp[i,]$RATIO;
		}
	}

# save data to file
write.table(
	ploidy.formatted,
	file = generate.filename(arguments$project, 'Sequenza_ploidy_purity','tsv'),
	row.names = FALSE,
	col.names = TRUE,
	sep = '\t'
	);

write.table(
	gene.data.cn,
	file = generate.filename(arguments$project, 'Sequenza_cna_gene_matrix', 'tsv'),
	row.names = FALSE,
	col.names = TRUE,
	sep = '\t'
	);

write.table(
	gene.data.ratio,
	file = generate.filename(arguments$project, 'Sequenza_ratio_gene_matrix', 'tsv'),
	row.names = FALSE,
	col.names = TRUE,
	sep = '\t'
	);

### SAVE SESSION INFO ##############################################################################
save.session.profile(generate.filename('CollectCNAs','SessionProfile','txt'));
