### plot_sv_summary.R ############################################################################
# Identify and plot recurrent SVs.
# INPUT:
#	- sv calls (combined mavis output)

### FUNCTIONS ######################################################################################
# function to generate a standardized filename
generate.filename <- function(project.stem, file.core, extension, include.date = TRUE) {

	# build up the filename
	file.name <- paste(project.stem, file.core, sep = '_');
	file.name <- paste(file.name, extension, sep = '.');

	if (include.date) {
		file.name <- paste(Sys.Date(), file.name, sep = '_');
		}

	return(file.name);
	}

# function to write session profile to file
save.session.profile <- function(file.name) {

	# open the file
	sink(file = file.name, split = FALSE);

	# write memory usage to file
	cat('### MEMORY USAGE ###############################################################');
	print(proc.time());

	# write sessionInfo to file
	cat("\n### SESSION INFO ###############################################################");
	print(sessionInfo());

	# close the file
	sink();

	}

### PREPARE SESSION ################################################################################
# import command line arguments
library(argparse);

parser <- ArgumentParser();

parser$add_argument('-p', '--project', type = 'character', help = 'PROJECT name');
parser$add_argument('-o', '--output', type = 'character', help = 'path to output directory');
parser$add_argument('-r', '--ref_type', type = 'character', help = 'reference genome', default = 'hg38');
parser$add_argument('-m', '--mavis', type = 'character',
	help = 'combined variant calls (generated by collect_mavis_output.R)');
parser$add_argument('-z', '--report', type = 'character', help = 'path to report directory',
	default = 'NULL');

arguments <- parser$parse_args();

# import libraries
library(BoutrosLab.plotting.general);
library(UpSetR);
library(RCircos);
library(xtable);

### READ DATA ######################################################################################
# get data
if (is.null(arguments$mavis)) {
	stop('ERROR: No input SV calls provided, please provide path to SV calls from MAVIS.');
	} else {
	sv.data <- read.delim(arguments$mavis, stringsAsFactors = FALSE);
	}

# read in list of known driver genes (Cancer Gene Census from COSMIC)
if (file.exists('/cluster/projects/pughlab/references/COSMIC/cancer_gene_census_20210414.tsv')) {
	driver.genes <- read.delim(
		'/cluster/projects/pughlab/references/COSMIC/cancer_gene_census_20210414.tsv',
		comment.char = '#'
		);

	driver.genes <- driver.genes[grepl('fusion',driver.genes$Role.in.Cancer),];
	} else {
	driver.genes <- NULL;
	}

# create (if necessary) and move to output directory
if (!dir.exists(arguments$output)) {
	dir.create(arguments$output);
	}

setwd(arguments$output);

### FILTER DATA ####################################################################################
print(paste0("Total SVs: ", nrow(sv.data)));

# determine SV status (germline/somatic)
sv.data$Status <- apply(
	sv.data[,grep('normal_genome|normal_transcriptome', colnames(sv.data))],
	1, function(i) {
		if (any(grepl('germline|Not Applicable', i))) {
			return('germline') } else { return('somatic') }
		}
	);

# remove short SVs (INDELs)
sv.data$Length <- abs(sv.data$break2_position_end - sv.data$break1_position_start);
sv.data[grepl('translocation', sv.data$event_type),]$Length <- NA;
sv.data <- sv.data[which(is.na(sv.data$Length) | sv.data$Length > 200),];

# add evidence filter
sv.data$Evidence <- apply(
	sv.data[,c('break1_split_reads','break2_split_reads','spanning_reads','linking_split_reads')],
	1, function(i) {
	if (any(i == 'None')) { i[which(i == 'None')] <- 0; }
	i <- sapply(i, function(j) { max(as.numeric(unlist(strsplit(as.character(j),';')))); });
	# if call method uses spanning reads
	if (i[3] >= 20) { return('PASS')
		# if call method uses split reads
		} else if (i[1] >= 20 & i[2] >= 20) { return('PASS')
		} else if (i[3] >= 20) { return('PASS')
		} else if (i[4] >= 20) { return('PASS')
		} else { return('FAIL');
		}
	});

if (any(grepl(';', sv.data$tools))) {
	sv.data[grepl(';', sv.data$tools),]$Evidence <- 'PASS';
	}
sv.data <- sv.data[which(sv.data$Evidence == 'PASS'),];

print(paste0('Total SVs after filter: ', nrow(sv.data)));

# do some minor formatting
sv.data <- sv.data[,!grepl('transcriptome|genome', colnames(sv.data))];
sv.data$library <- gsub('-rna','',sv.data$library);

# split into germline and somatic
germline.svs <- sv.data[which(sv.data$Status == 'germline'),];
somatic.svs <- sv.data[which(sv.data$Status == 'somatic'),];

# add quick recurrence filter (likely false positives/artefacts)
print(paste0("Total germline SVs: ", nrow(germline.svs)));
print(paste0("Total somatic SVs: ", nrow(somatic.svs)));

### ORGANIZE GENE ANNOTATIONS ###################################################################### 
library(org.Hs.eg.db);

# find regions of interest (CDS/EXON)
if (arguments$ref_type %in% c('hg38','GRCh38')) {
	library(TxDb.Hsapiens.UCSC.hg38.knownGene);
	txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene;
	} else if (arguments$ref_type %in% c('hg19','GRCh37')) {
	library(TxDb.Hsapiens.UCSC.hg19.knownGene);
	txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene;
	}

# organize all transcripts by GeneID
txdb_table <- transcriptsBy(txdb, by = 'gene');

# extract GeneIDs
tx_ids <- names(txdb_table);

# extract 
transcript_table <- select(
	TxDb.Hsapiens.UCSC.hg38.knownGene,
	keys = tx_ids,
	columns = c('GENEID','TXNAME','TXCHROM','TXSTART','TXEND'),
	keytype = 'GENEID'
	);
colnames(transcript_table)[1] <- 'ENTREZID';

# pull in extra annotations
transcript_table$SYMBOL <- mapIds(
	org.Hs.eg.db,
	keys = transcript_table$TXNAME,
	keytype = 'UCSCKG',
	column = 'SYMBOL'
	);

anno.data <- merge(
	aggregate(TXSTART ~ ENTREZID + SYMBOL + TXCHROM, transcript_table, min),
	aggregate(TXEND ~ ENTREZID + SYMBOL + TXCHROM, transcript_table, max)
	);
colnames(anno.data) <- c('ENTREZID','Gene','Chromosome','chromStart','chromEnd');
anno.data$Chromosome <- factor(anno.data$Chromosome, levels = paste0('chr',c(1:22,'X','Y')));
anno.data <- anno.data[order(anno.data$Chromosome, anno.data$chromStart),];

### FORMAT DATA ####################################################################################
# is this a tumour- or germline-only study?
if (nrow(somatic.svs) == 0) { # probably germline
	print("No somatic SVs detected. Using germline variants for downstream visualizations.");
	somatic.svs <- germline.svs;
	}

# summarize tool data
tool.list <- c();
if (any(somatic.svs$protocol == 'genome')) {
	tool.list <- c(tool.list, 'Manta','Delly','SViCT','NovoBreak','Pindel');
	}
if (any(somatic.svs$protocol == 'transcriptome')) {
	tool.list <- c(tool.list,'Arriba','FusionCatcher','STAR-Fusion');
	}

tool.summary <- data.frame(matrix(nrow = length(unique(somatic.svs$event_type))+1, ncol = length(tool.list)));
colnames(tool.summary) <- tool.list;
rownames(tool.summary) <- c('Total',unique(somatic.svs$event_type));

for (tool in colnames(tool.summary)) {
	for (type in rownames(tool.summary)) {

		counts <- if (type == 'Total') {
			nrow(somatic.svs[grepl(tolower(tool),somatic.svs$tools),]);
			} else {
			nrow(somatic.svs[grepl(tolower(tool),somatic.svs$tools) &
				grepl(type, somatic.svs$event_type),]);
			}

		tool.summary[type,tool] <- counts;
		}
	}

# now format data for plotting
tool.list <- unique(unlist(strsplit(as.character(somatic.svs$tools),';')));
tool.data <- as.data.frame(matrix(nrow = nrow(somatic.svs), ncol = length(tool.list), data = 0));
colnames(tool.data) <- tool.list;

for (tool in tool.list) {
	idx <- grepl(tool, somatic.svs$tools);
	tool.data[idx,tool] <- 1;
	}

# count variants
sample.counts <- data.frame(table(somatic.svs$library));
colnames(sample.counts) <- c('Sample','Count');
sample.counts <- sample.counts[order(sample.counts$Count),];

# summarize mutations
functional.summary <- data.frame(table(somatic.svs[,c('library','event_type')]));
functional.summary <- merge(functional.summary, sample.counts, by.x = 'library', by.y = 'Sample');
functional.summary$Proportion <- functional.summary$Freq / functional.summary$Count;
functional.summary$Tumor_Sample_Barcode <- factor(
	functional.summary$library,
	levels = sample.counts$Sample
	);

functional.summary$Class <- factor(
	functional.summary$event_type,
	levels = c('deletion','duplication','insertion','inversion','inverted translocation','translocation')
	);

functional.summary <- functional.summary[order(functional.summary$Tumor_Sample_Barcode, functional.summary$Class),];

# search for recurrent (somatic) events
tmp <- somatic.svs[which(somatic.svs$Fusion != 'None--None'),];

# first, bin by breakpoint (1kbp)
tmp$start_chr <- tmp$break1_chromosome;
tmp$end_chr <- tmp$break2_chromosome;
tmp$start_bin <- as.integer(floor(tmp$break1_position_start/10**3)*10**3);
tmp$end_bin <- as.integer(ceiling(tmp$break2_position_start/10**3)*10**3);

event.data <- unique(
	tmp[,c('library','event_type','Fusion','start_chr','end_chr','start_bin','end_bin')]
	);

event.data$Event <- paste0(
	'chr', event.data$start_chr, ':', event.data$start_bin,
	'_chr', event.data$end_chr, ':', event.data$end_bin
	);

event.counts <- aggregate(
	library ~ Fusion + event_type + Event,
	event.data,
	length
	);
colnames(event.counts)[4] <- 'Count';

event.counts <- event.counts[order(event.counts$Count, decreasing = TRUE),];
event.counts <- event.counts[which(event.counts$Count > 1),c('Event','Fusion','event_type','Count')];

recurrence.data <- list();
for (type in unique(sv.data$event_type)) {
	tmp <- event.counts[which(event.counts$event_type == type),];
	if (nrow(tmp) == 0) { next; }
	if (nrow(tmp) > 10) { tmp <- tmp[1:10,]; }
	recurrence.data[[type]] <- tmp[,c(1,2,4)];
	}

### PLOT DATA ######################################################################################
# plot tool summary (overlap plot)
png(filename = generate.filename(arguments$project, 'SV_tool_overlap','png'),
	res = 200, units = 'in', height = 4, width = 7);

upset(tool.data, sets = tool.list, mainbar.y.label = 'SVs Called By Indicated ToolSet',
	sets.x.label = 'SVs Called Per Tool');

dev.off();

# now set up variables for SV plots
sv.colour.scheme <- rev(default.colours(12))[1:6];
names(sv.colour.scheme) <- c('deletion','duplication','insertion','inversion','inverted translocation','translocation');

# make the plot legend (mutation type/consequence)
functional.legend <- legend.grob(
	legends = list(
		legend = list(
			colours = sv.colour.scheme[1:3],
			labels = names(sv.colour.scheme)[1:3]
			),
		legend = list(
			colours = sv.colour.scheme[4:6],
			labels = names(sv.colour.scheme)[4:6]
			)
		),
	layout = c(2,1),
	y = 0.1,
	size = 2
	);

# grab some parameters
tumour.samples <- unique(somatic.svs$library);

axis.cex <- if (length(tumour.samples) <= 30) { 1
	} else if (length(tumour.samples) <= 50) { 0.75
	} else if (length(tumour.samples) <= 80) { 0.5
	} else { 0 };

plot.height <- if (length(tumour.samples) <= 30) { 6
	} else if (length(tumour.samples) <= 50) { 8
	} else { 9 }

legend.pos <- if (plot.height == 6) { 1.55
	} else { 1.5 }

# create plot for functional summary
create.barplot(
	Tumor_Sample_Barcode ~ Freq,
	functional.summary,
	groups = functional.summary$Class,
	stack = TRUE,
	plot.horizontal = TRUE,
	col = sv.colour.scheme,
	yaxis.tck = if (axis.cex == 0) { 0 } else { c(0.5,0) },
	xaxis.tck = c(0.5,0),
	xaxis.fontface = 'plain',
	yaxis.fontface = 'plain',
	xlab.label = 'Count',
	xlab.cex = 1.2,
	ylab.label = NULL,
	yaxis.cex = axis.cex,
	xaxis.cex = 1,
	axes.lwd = 1,
	top.padding = 10,
	legend = list(
		inside = list(fun = functional.legend, x = 0.1, y = legend.pos)
		),
	height = plot.height,
	width = 7,
	resolution = 200,
	filename = generate.filename(arguments$project, 'somatic_sv_summary', 'png')
	);

save(
	sv.data,
	tool.summary,
	functional.summary,
	event.data,
	sv.colour.scheme,
	file = generate.filename(arguments$project, 'sv_summary', 'RData')
	);

# create circos plots
if (arguments$ref_type == 'hg38') {
	data(UCSC.HG38.Human.CytoBandIdeogram);
	cyto.info <- UCSC.HG38.Human.CytoBandIdeogram;
	} else if (arguments$ref_type == 'hg19') {
	data(UCSC.HG19.Human.CytoBandIdeogram);
	cyto.info <- UCSC.HG19.Human.CytoBandIdeogram;
	}

# recurrence across the cohort
plot.data <- data.frame(
	Chromosome = sapply(event.counts$Event, function(i) { unlist(strsplit(i,':|_'))[1] } ),
	chromStart = sapply(event.counts$Event, function(i) { as.numeric(unlist(strsplit(i,':|_'))[2])-5 }),
	chromEnd = sapply(event.counts$Event, function(i) { as.numeric(unlist(strsplit(i,':|_'))[2])+5 }),
	Chromosome.1 = sapply(event.counts$Event, function(i) { unlist(strsplit(i,':|_'))[3] } ),
	chromStart.1 = sapply(event.counts$Event, function(i) { as.numeric(unlist(strsplit(i,':|_'))[4])-5 }),
	chromEnd.1 = sapply(event.counts$Event, function(i) { as.numeric(unlist(strsplit(i,':|_'))[4])+5 }),
	PlotColor = sv.colour.scheme[match(event.counts$event_type, names(sv.colour.scheme))],
	Count = event.counts$Count 
	);

if (nrow(plot.data) > 15) {
	plot.data <- plot.data[!grepl('None', event.counts$Fusion),];
	plot.data <- plot.data[which(plot.data$Chromosome != 'chrY' & plot.data$Chromosome.1 != 'chrY'),];
	}

geneset <- intersect(
	driver.genes$Hugo_Symbol,
	unique(unlist(sapply(event.counts$Fusion,
		function(i) { setdiff(unlist(strsplit(i,'--')),'None') } )))
	);

gene.data <- anno.data[which(anno.data$Gene %in% geneset),c(3,4,5,2)];

if (nrow(gene.data) == 0) {
	geneset <- unique(unlist(sapply(event.counts$Fusion, function(i) { setdiff(unlist(strsplit(i,'--')),'None') } )));
	gene.data <- anno.data[which(anno.data$Gene %in% geneset),c(3,4,5,2)];
	}

# plot results (if any)
if (nrow(plot.data) > 0) {

	# set-up circos environment
	RCircos.Set.Core.Components(cyto.info, chr.exclude = 'chrY', tracks.inside = 2, tracks.outside = 0);

	rcircos.params <- RCircos.Get.Plot.Parameters();
	rcircos.params$text.size <- 0.5;
	RCircos.Reset.Plot.Parameters(rcircos.params);

	# initialize image
	png(filename = generate.filename(arguments$project, 'recurrent_SV_circos','png'),
		res = 200, units = 'in', height = 8, width = 7);

	RCircos.Set.Plot.Area(margin = 0.01);

	par(mai=c(1.1, 0.1, 0.1, 0.1));
	plot.new();
	plot.window(c(-1.4, 1.4), c(-1.4, 1.4));

	RCircos.Draw.Chromosome.Ideogram();
	RCircos.Label.Chromosome.Names();

	if (nrow(gene.data) > 0) {
		RCircos.Gene.Connector.Plot(gene.data, track.num = 1, side = 'in');
		RCircos.Gene.Name.Plot(gene.data, name.col = 4, track.num = 2, side = 'in');
		}

	# ensure ordering
	x <- RCircos.Get.Paired.Points.Positions(plot.data, genomic.columns = 3, plot.type = "link");
	RCircos.Link.Plot(plot.data, track.num = 4, by.chromosome = FALSE, lineWidth = x$Count);

	grid.draw(functional.legend);

	dev.off();
	}

# for each sample
for (smp in tumour.samples) {

	if (!dir.exists(smp)) {
		dir.create(smp);
		}

	setwd(smp);

	# get sample data
	smp.data <- somatic.svs[which(somatic.svs$library == smp),];

	plot.data <- data.frame(
		Chromosome = paste0('chr', smp.data$break1_chromosome),
		chromStart = smp.data$break1_position_start,
		chromEnd = smp.data$break1_position_end,
		Chromosome.1 = paste0('chr', smp.data$break2_chromosome),
		chromStart.1 = smp.data$break2_position_start,
		chromEnd.1 = smp.data$break2_position_end,
		PlotColor = sv.colour.scheme[match(smp.data$event_type, names(sv.colour.scheme))],
		Evidence = sapply(smp.data$tools, function(i) { length(unlist(strsplit(i,';'))) } )
		);

	plot.data[which(plot.data$Evidence == 1),]$Evidence <- 0.5;
	if (any(smp.data$Fusion == 'None--None')) {
		plot.data[which(smp.data$Fusion == 'None--None'),]$Evidence <- 0.5;
		}

	geneset.orig <- setdiff(c(smp.data$gene1_aliases, smp.data$gene2_aliases),'None');
	if (!is.null(driver.genes) & (length(geneset) > 20)) {
		geneset <- intersect(geneset.orig, c('NRG1','NRG2',driver.genes$Hugo_Symbol));
		}
	if (length(geneset) == 0) { geneset <- geneset.orig; }
	if (length(geneset) > 0) {
		gene.data <- anno.data[which(anno.data$Gene %in% geneset),c(3,4,5,2)];

		gene.data$Diff <- NA;
		for (chr in unique(gene.data$Chromosome)) {
			gene.data[which(gene.data$Chromosome == chr),]$Diff <- c(100,
				diff(gene.data[which(gene.data$Chromosome == chr),]$chromEnd/10**6))
			}

		while (any(gene.data$Diff < 20)) {

			idx <- which(gene.data$Diff < 20);
			gene.data <- gene.data[-idx[1],];

			gene.data$Diff <- NA;
			for (chr in unique(gene.data$Chromosome)) {
				gene.data[which(gene.data$Chromosome == chr),]$Diff <- c(100,
					diff(gene.data[which(gene.data$Chromosome == chr),]$chromEnd/10**6))
				}
			}
		}

	# plot results (if any)
	if (nrow(plot.data) > 0) {

		# set-up circos environment
		RCircos.Set.Core.Components(cyto.info, chr.exclude = NULL, tracks.inside = 2, tracks.outside = 0);

		rcircos.params <- RCircos.Get.Plot.Parameters();
		rcircos.params$text.size <- 0.5;
		RCircos.Reset.Plot.Parameters(rcircos.params);

		# initialize image
		png(filename = generate.filename(smp, 'hc_SV_circos','png'),
			res = 200, units = 'in', height = 8, width = 8);

		RCircos.Set.Plot.Area(margin = 0.01);

		par(mai=c(0.1, 0.1, 0.1, 0.1));
		plot.new();
		plot.window(c(-1.4, 1.4), c(-1.4, 1.4));

		RCircos.Draw.Chromosome.Ideogram();
		RCircos.Label.Chromosome.Names();

		if (nrow(gene.data) > 0) {
			RCircos.Gene.Connector.Plot(gene.data, track.num = 1, side = 'in');
			RCircos.Gene.Name.Plot(gene.data, name.col = 4, track.num = 2, side = 'in');
			}

		# ensure ordering
		x <- RCircos.Get.Paired.Points.Positions(plot.data, genomic.columns = 3, plot.type = "link");
		RCircos.Link.Plot(plot.data, track.num = 4, by.chromosome = FALSE, lineWidth = x$Evidence);

		dev.off();
		}

	# plot results (if any)
	if (nrow(plot.data[which(plot.data$Evidence > 0.5),]) > 0) {

		# set-up circos environment
		RCircos.Set.Core.Components(cyto.info, chr.exclude = NULL, tracks.inside = 2, tracks.outside = 0);

		rcircos.params <- RCircos.Get.Plot.Parameters();
		rcircos.params$text.size <- 0.5;
		RCircos.Reset.Plot.Parameters(rcircos.params);

		# initialize image
		png(filename = generate.filename(smp, 'hc_SV_circos__filtered','png'),
			res = 200, units = 'in', height = 8, width = 8);

		RCircos.Set.Plot.Area(margin = 0.01);

		par(mai=c(0.1, 0.1, 0.1, 0.1));
		plot.new();
		plot.window(c(-1.4, 1.4), c(-1.4, 1.4));

		RCircos.Draw.Chromosome.Ideogram();
		RCircos.Label.Chromosome.Names();

		if (nrow(gene.data) > 0) {
			RCircos.Gene.Connector.Plot(gene.data, track.num = 1, side = 'in');
			RCircos.Gene.Name.Plot(gene.data, name.col = 4, track.num = 2, side = 'in');
			}

		# ensure ordering
		x <- RCircos.Get.Paired.Points.Positions(
			plot.data[which(plot.data$Evidence > 0.5),],
			genomic.columns = 3, plot.type = "link");
		RCircos.Link.Plot(plot.data[which(plot.data$Evidence > 0.5),], 
			track.num = 4, by.chromosome = FALSE, lineWidth = x$Evidence);

		dev.off();
		}

	setwd(arguments$output);
	}

# run unlink, in case it exists from a previous run
if (!is.null(arguments$report)) {

	unlink(paste0(arguments$report, '/', 'SV_tool_overlap.png'));
	file.symlink(
		paste0(arguments$output, '/',
			generate.filename(arguments$project, 'SV_tool_overlap','png')),
		paste0(arguments$report, '/', 'SV_tool_overlap.png')
		);

	unlink(paste0(arguments$report, '/', 'somatic_sv_summary.png'));
	file.symlink(
		paste0(arguments$output, '/',
			generate.filename(arguments$project, 'somatic_sv_summary','png')),
		paste0(arguments$report, '/', 'somatic_sv_summary.png')
		);

	unlink(paste0(arguments$report, '/', 'recurrent_SV_circos.png'));
	file.symlink(
		paste0(arguments$output, '/',
			generate.filename(arguments$project, 'recurrent_SV_circos','png')),
		paste0(arguments$report, '/', 'recurrent_SV_circos.png')
		);
	}

### LATEX ##########################################################################################
# if making output for a report
if (!is.null(arguments$report)) {

	tex.file <- paste0(
		arguments$report,
		'/sv_summary.tex'
		);

	# write for latex
	write("\\section{SV Summary}", file = tex.file);

	if (nrow(sv.data) == 0) {
		write("No high-confidence structural variants detected.", file = tex.file, append = TRUE);
		} else {
		print(
			xtable(
				tool.summary,
				caption = 'Number of events (total and by SV type) discovered by each tool, as well as the overlap, and verified by MAVIS.'
				),
			file = tex.file,
			include.rownames = TRUE,
			append = TRUE
			);

		write("\\vspace{1.0cm}\n\\begin{figure}[h!]", file = tex.file, append = TRUE);
		write("\\begin{center}", file = tex.file, append = TRUE);
		write(paste0(
			"\\includegraphics[width=0.9\\textwidth]{",
			paste0(arguments$report, '/', 'SV_tool_overlap.png'), '}'
			), file = tex.file, append = TRUE);
		write("\\end{center}", file = tex.file, append = TRUE);
		write("\\caption{Number of structural variants detected by each tool or set of tools.}",
			file = tex.file, append = TRUE);
		write("\\end{figure}\n", file = tex.file, append = TRUE);

		write("\\pagebreak\n\\begin{figure}[h!]", file = tex.file, append = TRUE);
		write("\\begin{center}", file = tex.file, append = TRUE);
		write(paste0(
			"\\includegraphics[width=0.9\\textwidth]{",
			paste0(arguments$report, '/', 'somatic_sv_summary.png'), '}'
			), file = tex.file, append = TRUE);
		write("\\end{center}", file = tex.file, append = TRUE);
		write("\\caption{Number of structural variants detected in tumour samples, split by event type.}",
			file = tex.file, append = TRUE);
		write("\\end{figure}\n", file = tex.file, append = TRUE);

		if (nrow(event.counts) == 0) {
			write("No events were recurrently detected across the cohort.",
				file = tex.file, append = TRUE);
			} else {

			write("\\pagebreak\n\\subsection{Recurrent SVs}", file = tex.file, append = TRUE);

			write("\\begin{figure}[h!]", file = tex.file, append = TRUE);
			write("\\begin{center}", file = tex.file, append = TRUE);
			write(paste0(
				"\\includegraphics[width=0.9\\textwidth]{",
				paste0(arguments$report, '/', 'recurrent_SV_circos.png'), '}'
				), file = tex.file, append = TRUE);
			write("\\end{center}", file = tex.file, append = TRUE);
			write("\\caption{Summary of structural variants detected across the cohort; colour indicates variant type while line width indicates recurrence (thicker lines = more samples).}",
				file = tex.file, append = TRUE);
			write("\\end{figure}\n", file = tex.file, append = TRUE);

			for (type in names(recurrence.data)) {
				tmp <- xtable(
					recurrence.data[[type]],
					caption = paste0('Recurrent ', type, ' events; all recurrent events (or top 10) are shown. Recurrent is defined as a given event type detected with identical breakpoints ($\\pm$1kbp) across multiple tumour samples.')
					);
				print(
					tmp,
					file = tex.file,
					include.rownames = FALSE,
					append = TRUE
					);
				}
			}
		}
	}

### SAVE SESSION INFO ##############################################################################
save.session.profile(generate.filename('SV_Summary','SessionProfile','txt'));
