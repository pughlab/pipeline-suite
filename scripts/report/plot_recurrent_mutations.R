### plot_recurrent_mutations.R #####################################################################
# Find and plot recurrently altered geneset

### FUNCTIONS ######################################################################################
# function to generate a standardized filename
generate.filename <- function(project.stem, file.core, extension, include.date = TRUE) {

	# build up the filename
	file.name <- paste(project.stem, file.core, sep = '_');
	file.name <- paste(file.name, extension, sep = '.');

	if (include.date) {
		file.name <- paste(Sys.Date(), file.name, sep = '_');
		}

	return(file.name);
	}

# function to write session profile to file
save.session.profile <- function(file.name) {

	# open the file
	sink(file = file.name, split = FALSE);

	# write memory usage to file
	cat('### MEMORY USAGE ###############################################################');
	print(proc.time());

	# write sessionInfo to file
	cat("\n### SESSION INFO ###############################################################");
	print(sessionInfo());

	# close the file
	sink();

	}

### VARIANT CODING
# 1 = missense, 2 = stop gain, 3 = stop loss, 4 = splicing, 5 = frameshift, 6 = in frame indel, 7 = tss
# 8 = RNA, 9 = other (up/downstream, UTR, intergenic, silent, intron), 10 = ITD
variant.codes <- data.frame(
	Classification = c("3'Flank", "5'Flank", "Intron", "RNA", "IGR", "3'UTR", "5'UTR", "Silent",
		"Missense_Mutation", "Splice_Region", "Splice_Site", "In_Frame_Del", "In_Frame_Ins",
		"Frame_Shift_Del", "Frame_Shift_Ins", "Nonsense_Mutation", "Nonstop_Mutation",
		"Translation_Start_Site", "ITD"),
	Group = c('other','other','other','RNA','other','other','other','other','missense',
		'splice_site','splice_site','in_frame_indel','in_frame_indel','frameshift_indel',
		'frameshirt_indel', 'nonsense', 'nonstop', 'tss', 'itd'),
	Code = c(9, 9, 9, 8, 9, 9, 9, 9, 1, 4, 4, 6, 6, 5, 5, 2, 3, 7, 10)
	);

### PREPARE SESSION ################################################################################
# import command line arguments
library(argparse);

parser <- ArgumentParser();

parser$add_argument('-p', '--project', type = 'character', help = 'PROJECT name');
parser$add_argument('-o', '--output', type = 'character', help = 'path to output directory');
parser$add_argument('-t', '--seq_type', type = 'character', help = 'exome or wgs', default = 'exome');
parser$add_argument('--maf', type = 'character', help = 'combined mutation calls in MAF format');
parser$add_argument('--tmb', type = 'character', help = 'path to TMB metrics');
parser$add_argument('--mutsig', type = 'character', help = 'path to mutsig output (*.sig_genes.txt)');
parser$add_argument('-z', '--report', type = 'character', help = 'path to report directory',
	default = 'NULL');

arguments <- parser$parse_args();

# import libraries
library(BoutrosLab.plotting.general);
library(xtable);

# set some colour schemes
variant.colours <- c('darkseagreen4','darkorchid4','#9AA3F2','yellow','darkorange3','#F9B38E','turquoise1','plum','grey50')
names(variant.colours) <- c('missense','nonsense','nonstop','splicing','frameshift_indel','in_frame_indel','tss','RNA','noncoding');

# for these plots, we will ignore some variant types
variant.colours <- variant.colours[c(1:7,9)];

# read in list of known driver genes (Cancer Gene Census from COSMIC)
if (file.exists('/cluster/projects/pughlab/references/COSMIC/cancer_gene_census_20210414.tsv')) {
	driver.genes <- read.delim(
		'/cluster/projects/pughlab/references/COSMIC/cancer_gene_census_20210414.tsv',
		comment.char = '#'
		);

	driver.genes <- driver.genes[which(driver.genes$Hallmark == 'Yes'),];
	}

### READ DATA ######################################################################################
# get data
if (is.null(arguments$maf)) {
	stop('ERROR: No input MAF provided, please provide path to SNV calls in MAF format.');
	} else {
	input.data <- read.delim(arguments$maf, stringsAsFactors = FALSE, comment.char = '#');
	}

if (is.null(arguments$tmb)) {
	stop('ERROR: TMB data (generated by calculate_tmb.R) must be provided.');
	} else {
	tmb.data <- read.delim(arguments$tmb);
	if ('Method' %in% colnames(tmb.data)) {
		tmb.data <- tmb.data[which(tmb.data$Method == 'VEP'),];
		}
	if ('VAF' %in% colnames(tmb.data)) {
		if (arguments$seq_type == 'exome') {
			tmb.data <- tmb.data[which(tmb.data$VAF == 0.05),];
			}
		if (arguments$seq_type == 'wgs') {
			tmb.data <- tmb.data[which(tmb.data$VAF == 0.1),];
			}
		}
	}

if (is.null(arguments$mutsig)) {
	mutsig <- NULL; } else {
	mutsig <- read.delim(arguments$mutsig, row.names = 1);
	}

# collect list of all samples
all.samples <- sort(as.character(unique(input.data$Tumor_Sample_Barcode)));

# create (if necessary) and move to output directory
if (!dir.exists(arguments$output)) {
	dir.create(arguments$output);
	}

setwd(arguments$output);

### FORMAT DATA ####################################################################################
# indicate key fields
#keep.fields <- c('Tumor_Sample_Barcode','Hugo_Symbol','Chromosome','Variant_Classification','Reference_Allele','Tumor_Seq_Allele2');

keep.fields <- c('Tumor_Sample_Barcode','Hugo_Symbol','Chromosome','Variant_Classification','Reference_Allele','Tumor_Seq_Allele2','HGVSc','HGVSp_Short','CLIN_SIG','dbSNP_RS','t_vaf','n_vaf');

print(paste0("Total variants: ", nrow(input.data), " among ", length(all.samples), " samples."));

# add quick recurrence filter (likely false positives/artefacts)
recurrence.data <- aggregate(
	Tumor_Sample_Barcode ~ Chromosome + Start_Position + End_Position + Allele,
	input.data,
	length
	);
colnames(recurrence.data)[ncol(recurrence.data)] <- 'RecurrenceCount';

recurrence.threshold <- floor(length(all.samples)*0.9);
tmp <- merge(input.data, recurrence.data, all.x = TRUE);
tmp <- tmp[which(tmp$RecurrenceCount < recurrence.threshold),];

print(paste0("Removing ",
	nrow(recurrence.data[which(recurrence.data$RecurrenceCount > recurrence.threshold),]),
	" variants due to too high recurrence (>= 90% [n = ",
	recurrence.threshold,
	"] of samples)."
	));

mutation.data <- tmp;

rm(tmp,recurrence.data);

# add a VAF threshold
mutation.data$t_vaf <- mutation.data$t_alt_count / mutation.data$t_depth;
mutation.data$n_vaf <- 1 - (mutation.data$n_ref_count / mutation.data$n_depth);
vaf.threshold <- 0.01;

remove.idx <- which(mutation.data$t_vaf < vaf.threshold);
print(paste0(
	"Removing ", length(remove.idx), " (",
	round(length(remove.idx) / nrow(mutation.data) * 100, digits = 2), " %)",
	" variants with VAF < ", vaf.threshold
	));
	
mutation.data <- mutation.data[which(mutation.data$t_vaf >= vaf.threshold),];

# add a read threshold
remove.idx <- which(mutation.data$t_alt_count < 3);
print(paste0(
	"Removing ", length(remove.idx), " (",
	round(length(remove.idx) / nrow(mutation.data) * 100, digits = 2), " %)",
	" variants with fewer than 3 alternate allele reads" 
	));

mutation.data <- mutation.data[which(mutation.data$t_alt_count >= 3),];

# add a coverage threshold
remove.idx <- which(mutation.data$t_depth < 20);
print(paste0(
	"Removing ", length(remove.idx), " (",
	round(length(remove.idx) / nrow(mutation.data) * 100, digits = 2), " %)",
	" variants with low coverage" 
	));

mutation.data <- mutation.data[which(mutation.data$t_depth >= 20),keep.fields];

# apply variant coding
mutation.data$Code <- variant.codes$Code[match(mutation.data$Variant_Classification, variant.codes$Classification)];
mutation.data <- mutation.data[which(mutation.data$Code != 8),];

# remove silent mutations
remove.idx <- which(mutation.data$Variant_Classification %in% c('Silent','Intron','IGR'));
print(paste0(
	"Removing ", length(remove.idx), " (",
	round(length(remove.idx) / nrow(mutation.data) * 100, digits = 2), " %)",
	" variants with classifications of silent/intron/IGR."
	));

mutation.data <- mutation.data[-remove.idx,];

# extract clinvar pathogenic hits
mutation.data$ClinVar <- sapply(mutation.data$CLIN_SIG, function(i) { 
	if (is.na(i)) { return(NA) 
		} else {
		tmp <- unlist(strsplit(i,','));
		x <- if (any(tmp == 'pathogenic')) { 'pathogenic'
			} else if (any(tmp == 'likely_pathogenic')) { 'likely_pathogenic'
			} else if (any(tmp %in% c('uncertain_significance','conflicting_interpretations_of_pathogenicity'))) { 'VUS'
			} else if (any(tmp == 'likely_benign')) { 'likely_benign'
			} else if (any(tmp == 'benign')) { 'benign'
			} else { NA }
		return(x);
		}
	});

# if there are fewer than 5 germline variants here, write a table to output
mutation.data$Variant <- apply(mutation.data[,c('HGVSc','HGVSp_Short','Variant_Classification')], 1, 
	function(i) {
		j <- setdiff(i[1:2],'');
		if (length(j) == 2) { return(paste0(j[1], ' (', j[2], ')'));
			} else if (length(j) == 1) { return(j[1]);
			} else { return(i[3]) }
		}
	);

# select pathogenic hits
signif.data <- mutation.data[which(mutation.data$ClinVar %in% c('pathogenic','likely_pathogenic')),c('Tumor_Sample_Barcode','Hugo_Symbol','Variant','ClinVar','dbSNP_RS','t_vaf')];
colnames(signif.data) <- c('Sample','Symbol','Variant','ClinVar','dbSNP','TumourVAF');

# save significant results for each sample
for (smp in all.samples) {

	if (!dir.exists(smp)) {
		dir.create(smp);
		}

	smp.data <- signif.data[which(signif.data$Sample == smp),];
	if (nrow(smp.data) == 0) { next; }

	setwd(smp);

	write.table(
		smp.data,
		file = generate.filename('ENSEMBLE', 'pathogenic_somatic_variants','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);

	print(
		xtable(
			smp.data[,-1],
			caption = 'List of high-confidence, pathogenic somatic mutations.'
			),
		file = 'pathogenic_somatic_variants.tex',
		include.rownames = FALSE
		);

	setwd(arguments$output);
	}


# reduce to 1 mutation per gene per sample [taking the higher priority code]
mutation.data.trimmed <- aggregate(
	Code ~ Tumor_Sample_Barcode + Hugo_Symbol + Chromosome,
	mutation.data,
	min
	);

# reshape data
plot.data <- reshape(
	mutation.data.trimmed,
	direction = 'wide',
	timevar = 'Tumor_Sample_Barcode',
	idvar = c('Chromosome','Hugo_Symbol')
	);
colnames(plot.data) <- gsub('Code.','',colnames(plot.data));

# ensure all samples are accounted for
absent.smps <- setdiff(all.samples, colnames(plot.data));
if (length(absent.smps) > 0) { plot.data[,absent.smps] <- NA; }

# get per-gene sample counts
plot.data <- plot.data[,c('Hugo_Symbol', 'Chromosome', all.samples)];

print(paste0("Found ", nrow(plot.data), " genes with non-silent mutations."));

if (length(all.samples) > 1) {

	# if WGS, prioritize coding mutations
	if ('wgs' == arguments$seq_type) {
		plot.data$Count <- apply(
			plot.data[,all.samples],1,function(i) { length(i[which(i < 9)]) } );
		} else {
		plot.data$Count <- apply(
			plot.data[,all.samples],1,function(i) { length(i[!is.na(i)]) } );
		}

	# prioritize missense/nonsense/splicing mutations
	plot.data$Priority <- apply(
		plot.data[,all.samples],1,function(i) { length(i[which(i < 4)]) } )/plot.data$Count;
	plot.data <- plot.data[order(plot.data$Count, plot.data$Priority, decreasing = TRUE),];

	# if there are no missense/nonsense/splicing mutations, include remaining non-coding mutations
	if (all(is.na(plot.data$Priority))) {
		plot.data$Priority <- apply(
			plot.data[,all.samples],1,function(i) { length(i[which(i < 9)]) } )/plot.data$Count;
		plot.data <- plot.data[order(plot.data$Count, plot.data$Priority, decreasing = TRUE),];
		}

	# break ties using driver genes
	if (exists('driver.genes')) {
		driver.idx <- which(plot.data$Hugo_Symbol %in% driver.genes$Hugo_Symbol);
		plot.data[driver.idx,]$Priority <- plot.data[driver.idx,]$Priority + 0.1;
		plot.data <- plot.data[order(plot.data$Count, plot.data$Priority, decreasing = TRUE),];
		}

	# remove non-recurrently mutated genes
	print(paste0("Removing ",
		length(which(plot.data$Count == 1)),
		" genes with mutations in a single sample."
		));

	plot.data <- plot.data[which(plot.data$Count > 1),];

	# add MutSigCV significance
	if (!is.null(arguments$mutsig)) {

		tmp <- merge(
			plot.data,
			mutsig[,c('p','q')],
			by.x = 'Hugo_Symbol',
			by.y = 'row.names',
			all.x = TRUE
			);

		plot.data <- tmp[order(-tmp$Count, tmp$p),];
		rm(tmp);
		}

	} else {
	plot.data$Count <- 1;
	}

# remove known problem (passenger) genes
genes.to.exclude <- c('TTN','MUC17','OBSCN','MUC16','SYNE2','NEB','SYNE1');
remove.idx <- which(plot.data$Hugo_Symbol %in% genes.to.exclude);
print(paste0("Removing commonly-mutated genes (likely passenger mutations): ",
	paste(genes.to.exclude, collapse = ',')
	));

plot.data <- plot.data[which(!plot.data$Hugo_Symbol %in% genes.to.exclude),];

print(paste0(
	"Resulting list contains ",
	nrow(plot.data),
	" recurrently mutated genes (2 or more samples)."
	));

# trim down to top recurrently mutated genes (or top 20, whichever is smallest)
print("Preparing data for plotting...");

tophit.flag <- 'none';

plot.data$KEEP <- NA;

# filter by significance if available
if (!is.null(arguments$mutsig)) {

	if (length(which(plot.data$p < 0.01)) >= 20) { threshold <- 0.01;
		} else if (length(which(plot.data$p < 0.05)) >= 20) { threshold <- 0.05;
		} else if (length(which(plot.data$p < 0.10)) >= 20) { threshold <- 0.10; }

	print(paste0("> Selecing genes with MutSigCV p-value < ", threshold));
	plot.data[which(plot.data$p < threshold),]$KEEP <- 'mutsig';
	}

# filter by recurrence (if N is good for plotting)
top.count <- setdiff(
	which(plot.data$Count > length(all.samples)*0.2),
	which(plot.data$KEEP == 'mutsig')
	);

if (length(top.count) > 0) {
	plot.data[top.count,]$KEEP <- 'recurrent';
	}

# plot known oncogenes/tumour suppressors
if (exists('driver.genes')) {
	# plot known tumour suppressors
	driver.idx <- which(plot.data$Hugo_Symbol %in% driver.genes$Hugo_Symbol);
	if (length(driver.idx) == 0) { next; }
	plot.data[driver.idx,]$KEEP <- sapply(
		plot.data[driver.idx,]$KEEP, function(i) { paste(na.omit(c(i,'driver')),collapse = '_') }
		);
	}

plot.data$KEEP <- factor(plot.data$KEEP,
	levels = c('mutsig_driver','mutsig','recurrent_driver','recurrent','driver')
	);
plot.data <- plot.data[order(plot.data$KEEP, -plot.data$Count),];

plot.data.full <- plot.data;

if (nrow(plot.data[!is.na(plot.data$KEEP),]) <= 20 & nrow(plot.data[!is.na(plot.data$KEEP),]) > 5) {
	plot.data <- plot.data[!is.na(plot.data$KEEP),];
	} else {
	print("Too many genes still remaining; selecting first 20 for plotting.");
	plot.data <- plot.data[1:20,];
	}

# clean up for plotting
plot.data$Label <- as.character(plot.data$Hugo_Symbol);
if (any(duplicated(plot.data$Hugo_Symbol))) {
	dup.symbols <- unique(plot.data$Hugo_Symbol[duplicated(plot.data$Hugo_Symbol)]);
	for (gene in dup.symbols) {
		tmp <- plot.data[which(plot.data$Hugo_Symbol == gene),1:2];
		new.symbols <- paste0(plot.data$Hugo_Symbol, '_', plot.data$Chromosome);
		plot.data[which(plot.data$Hugo_Symbol == gene),]$Label <- new.symbols;
		}
	}

# organize data for prettier heatmap
if (length(all.samples) > 1) {
	heatmap.data <- t(plot.data[,all.samples]);
	heatmap.data[!is.na(heatmap.data)] <- 1;
	heatmap.data <- heatmap.data[do.call(order, transform(heatmap.data)),];

	sample.order <- rownames(heatmap.data);
	gene.order <- colnames(heatmap.data);
	} else {
	sample.order <- all.samples;
	gene.order <- rownames(plot.data);
	}

### MAKE PLOTS #####################################################################################
# make the plot legend (mutation type/consequence)
functional.legend <- legend.grob(
	legends = list(
		legend = list(
			colours = variant.colours,
			labels = names(variant.colours)
			)
		),
	title.just = 'left',
	size = 2
	);

# grab some parameters
axis.cex <- if (length(all.samples) <= 30) { 1
	} else if (length(all.samples) <= 50) { 0.75
	} else if (length(all.samples) <= 80) { 0.5
	} else { 0 };

# create plot for mutation rates
ylim <- c(floor(min(log10(tmb.data$coding))), ceiling(max(log10(tmb.data$coding))));
if (any(tmb.data$coding == 0)) { ylim[1] <- 0; }
yat <- seq(ylim[1], ylim[2], 1);
yaxis.labels <- 10**yat;
tmb.data$Rate <- log10(tmb.data$coding);

if (ylim[2] == 1) {
	ylim <- c(0, ceiling(max(tmb.data$coding)));
	yat <- if (ylim[2] > 5) { seq(0,ylim[2]+1,2); } else { seq(0,ylim[2],1); }
	yaxis.labels <- yat;
	tmb.data$Rate <- tmb.data$coding;
	}

tmb.data$ID <- factor(tmb.data$ID, levels = sample.order);

rate.plot <- create.barplot(
	Rate ~ ID,
	tmb.data,
	xaxis.lab = rep('', nrow(tmb.data)+1),
	yaxis.cex = 1,
	xaxis.tck = 0,
	yaxis.tck = c(0.5,0),
	axes.lwd = 1,
	origin = ylim[1],
	box.ratio = if (length(all.samples) > 20) { 1 } else { 2 },
	ylab.label = 'SNVs/Mbp',
	ylab.cex = 1.2,
	ylimits = ylim,
	yat = yat,
	yaxis.lab = yaxis.labels,
	xlab.label = NULL,
	style = 'Nature'
	);

# create heatmap for recurrent genes (ordered by recurrence)
if (length(sample.order) == 1) {
	plot.data$Sample2 <- plot.data[,sample.order];
	sample.order <- c(sample.order, 'Sample2');
	}

recurrence.plot <- create.heatmap(
	plot.data[,sample.order],
	cluster.dimensions = 'none',
	same.as.matrix = TRUE,
	xaxis.lab = if (length(all.samples) == 1) { all.samples } else { sample.order },
	xat = if (length(all.samples) == 1) { 1.5 } else { TRUE },
	yaxis.lab = plot.data$Label,
	xaxis.cex = axis.cex,
	yaxis.cex = 1,
	xaxis.tck = if (axis.cex == 0) { 0 } else { 0.2 },
	yaxis.tck = 0.2,
	axes.lwd = 1,
	grid.row = TRUE,
	force.grid.row = TRUE,
	row.colour = 'grey80',
	col.colour = 'grey80',
	row.lwd = if (length(all.samples) < 30) { 3 } else { 1 },
	col.lwd = if (length(all.samples) < 30) { 3 } else { 1 },
	grid.col = (length(all.samples) > 1),
	force.grid.col = (length(all.samples) > 1),
	print.colour.key = FALSE,
	fill.colour = 'white',
	at = seq(0,length(variant.colours),1),
	total.colours = length(variant.colours)+1,
	colour.scheme = variant.colours,
	style = 'Nature'
	);

recurrence.plot$y.scales$fontface <- 'italic';

# plot MutSig results (if provided)
if (!is.null(arguments$mutsig)) {

	plot.data$Label <- factor(plot.data$Label, levels = rev(as.character(plot.data$Label)));

	if (min(plot.data$p, na.rm = TRUE) < 10**-20) {
		plot.data[which(plot.data$p < 10**-20),]$p <- 10**-20;
		}
	if (min(plot.data$q, na.rm = TRUE) < 10**-20) {
		plot.data[which(plot.data$q < 10**-20),]$q <- 10**-20;
		}

	key1 <- list(
		rect = list(size = 2, col = 'black'),
		text = list(lab = 'p-value', cex = 0.8)
		);
	key2 <- list(
		points = list(pch = 16, col = 'red'),
		text = list(lab = 'FDR', cex = 0.8)
		);
	key3 <- list(
		lines = list(lty = 2, col = 'grey50', size = 2),
		text = list(lab = as.character(threshold), cex = 0.8)
		);
	
	mutsig.plot <- create.barplot(
		Label ~ -log10(p),
		plot.data,
		plot.horizontal = TRUE,
		ylab.label = NULL,
		xlab.label = expression('-log'['10']*'(value)'),
		xlab.cex = 1.5,
		yaxis.cex = 1,
		xaxis.cex = 1,
		yaxis.tck = c(0.5,0),
		xaxis.tck = c(0.5,0),
		abline.v = -log10(threshold),
		abline.col = 'grey50',
		abline.lty = 2,
		xlimits = c(0, ceiling(max(-log10(plot.data$p))) + 1),
		add.text = TRUE,
		text.labels = '\u2022',
		text.x = -log10(plot.data[which(plot.data$q < 1),]$q),
		text.y = nrow(plot.data) - (which(plot.data$q < 1)) + 1,
		text.col = 'red',
		legend = list(
			inside = list(fun = draw.key, args = list(key = key1), x = 1.04, y = 0.55),
			inside = list(fun = draw.key, args = list(key = key2), x = 1.1, y = 0.50),
			inside = list(fun = draw.key, args = list(key = key3), x = 1.04, y = 0.45)
			),
		right.padding = 12,
		style = 'Nature'
		);

	write.plot(
		mutsig.plot,
		height = 6,
		width = 4,
		resolution = 200,
		filename = generate.filename(arguments$project, 'MutSigCV_pvalues','png')
		);

	mutsig.plot <- create.barplot(
		Label ~ -log10(p),
		plot.data,
		plot.horizontal = TRUE,
		ylab.label = NULL,
		xlab.label = expression('-log'['10']*'(value)'),
		xlab.cex = 1.5,
		yaxis.lab = rep('', nrow(plot.data)),
		xaxis.cex = 1,
		yaxis.tck = 0,
		xaxis.tck = c(0.5,0),
		abline.v = -log10(threshold),
		abline.col = 'grey50',
		abline.lty = 2,
		xlimits = c(0, ceiling(max(-log10(plot.data$p))) + 1),
		add.text = TRUE,
		text.labels = '\u2022',
		text.x = -log10(plot.data[which(plot.data$q < 1),]$q),
		text.y = nrow(plot.data) - (which(plot.data$q < 1)) + 1,
		text.col = 'red',
		legend = list(
			inside = list(fun = draw.key, args = list(key = key1), x = 0.85, y = 0.5),
			inside = list(fun = draw.key, args = list(key = key2), x = 0.90, y = 0.45),
			inside = list(fun = draw.key, args = list(key = key3), x = 0.85, y = 0.4)
			),
		right.padding = 6,
		style = 'Nature'
		);
	}

# combine them!
if (!exists('mutsig.plot')) {

	create.multipanelplot(
		plot.objects = list(rate.plot, recurrence.plot),
		plot.objects.heights = c(1,4),
		left.legend.padding = 0,
		right.legend.padding = 0,
		top.legend.padding = 0,
		bottom.legend.padding = 0,
		y.spacing = -1,
		right.padding = if (length(all.samples) < 20) { 8 } else { 0 },
		legend = if (length(all.samples) < 20) { 
			list(inside = list(fun = functional.legend, x = 0.91, y = 0.7))
			} else { NULL },
		height = 8,
		width = if (length(all.samples) < 12) { 8 } else { 10 },
		resolution = 200,
		filename = generate.filename(arguments$project, 'snv_recurrent_genes','png')
		);

	} else {

	create.multipanelplot(
		plot.objects = list(rate.plot, recurrence.plot, mutsig.plot),
		layout.width = 2,
		layout.height = 2,
		layout.skip = c(FALSE,TRUE,FALSE,FALSE),
		plot.objects.heights = c(1,5),
		plot.objects.widths = c(4,1),
		left.legend.padding = 0,
		right.legend.padding = 0,
		top.legend.padding = 0,
		bottom.legend.padding = 0,
		y.spacing = 5,
		x.spacing = 0,
		xlab.axis.padding = -10,
		right.padding = 4,
		bottom.padding = 2,
		legend = list(
			inside = list(fun = functional.legend, x = 0.88, y = 0.88)
			),
		height = 8,
		width = if (length(all.samples) < 12) { 8 } else { 10 },
		resolution = 200,
		filename = generate.filename(arguments$project, 'snv_recurrent_genes','png')
		);
	}

# save key data to file
save(
	plot.data.full,
	variant.codes,
	variant.colours,
	file = generate.filename(arguments$project, 'snv_recurrence_summary', 'RData')
	);

# run unlink, in case it exists from a previous run
if (!is.null(arguments$report)) {
	unlink(paste0(arguments$report, '/', 'snv_recurrent_genes.png'));
	file.symlink(
		paste0(arguments$output, '/',
			generate.filename(arguments$project, 'snv_recurrent_genes','png')),
		paste0(arguments$report, '/', 'snv_recurrent_genes.png')
		);
	}

### LATEX ##########################################################################################
# write some captions
summary.caption <- "Summary of short somatic variants (SNVs, indels) for each sample. From top to bottom: summary of key mutation signatures including MSI and HRD status (CHORD and HRDetect) where available; proportion of mutations with indicated functional consequence (first barplot shows non-silent mutations while second shows all mutations); proportion of mutations with the indicated basechange.";

recurrence.caption <- "Top shows tumour mutation burden as calculated as number of coding mutations (SNV/INDELs) per million callable bases (specifically coding regions). Heatmap shows most frequently mutated genes across the cohort including ";
count <- 0;
if (any(grepl('mutsig', plot.data$KEEP))) {
	recurrence.caption <- paste0(
		recurrence.caption, "genes found to be significant by MutSigCV (p $<$ ", threshold, ")");
	count <- count + 1;
	}
if (any(grepl('recurrent', plot.data$KEEP))) {
	recurrence.caption <- paste0(
		recurrence.caption,
		if (count > 0) { ", " } else { "" },
		"genes with mutations detected in $>$20\\% of samples");
	count <- count + 1;
	}
if (any(grepl('driver', plot.data$KEEP))) {
	recurrence.caption <- paste0(
		recurrence.caption,
		if (count > 0) { " and/or " } else { "most frequent " },
		"known driver genes."
		);
	}

if (exists('mutsig.plot')) {
	recurrence.caption <- paste0(
		recurrence.caption,
		" Barplot (right) shows MutSigCV p-values for each gene in the heatmap."
		);
	}

recurrence.caption <- paste(
	recurrence.caption, 
	"Colours indicate predicted functional consequence (white = no mutation detected).",
	"Gene set is truncated to top 20 hits where necessary."
	);

# if making output for a report
if (!is.null(arguments$report)) {

	all.plots <- list.files(path = arguments$report, pattern = 'png', full.names = TRUE);
	names(all.plots) <- sapply(all.plots, basename);

	tex.file <- paste0(
		arguments$report,
		'/somatic_snv_summary.tex'
		);

	write("\\section{Somatic Mutation Summary}", file = tex.file);

	# first, check for mutation_overlap plot
	if (any('SNV_tool_overlap.png' %in% names(all.plots))) {
		tool.upset.plot <- all.plots['SNV_tool_overlap.png'];

		write("\\begin{figure}[h!]", file = tex.file, append = TRUE);
		write("\\begin{center}", file = tex.file, append = TRUE);
		write(paste0(
			"\\includegraphics[width=1\\textwidth]{",
			tool.upset.plot, '}'
			), file = tex.file, append = TRUE);
		write("\\end{center}", file = tex.file, append = TRUE);
		write(paste0(
			"\\caption{UpSet plot showing overlap across SNV/INDEL variant callers.}"
			), file = tex.file, append = TRUE);
		write("\\end{figure}\n\\pagebreak\n", file = tex.file, append = TRUE);
		}

	if (any('mutation_tool_overlap.png' %in% names(all.plots))) {
		tool.overlap.plot <- all.plots['mutation_tool_overlap.png'];

		write("\\begin{figure}[h!]", file = tex.file, append = TRUE);
		write("\\begin{center}", file = tex.file, append = TRUE);
		write(paste0(
			"\\includegraphics[height=0.85\\textheight]{",
			tool.overlap.plot, '}'
			), file = tex.file, append = TRUE);
		write("\\end{center}", file = tex.file, append = TRUE);
		write(paste0(
			"\\caption{Number of variants called by each tool (including Mutect, MuTect2, SomaticSniper, Strelka, Pindel, VarDict and VarScan) and the ensemble variants carried forward.}"
			), file = tex.file, append = TRUE);
		write("\\end{figure}\n\\pagebreak\n", file = tex.file, append = TRUE);
		}

	write("\\textbf{ENSEMBLE Variant Set:}\\\\", file = tex.file, append = TRUE);

	# describe filtering (if any tumour-only)
	if ( (grepl('oncokb_annotated_filtered.tsv', arguments$maf)) & (any(input.data$FLAG.tumour_only))) {
		write('Ensemble calls were filtered to remove probable false positives from tumour-only samples using the following criteria:',	file = tex.file, append = TRUE);

		write("\\begin{itemize}", file = tex.file, append = TRUE);
		write("\\item remove any variant with AF $>$ 0.001 in any population", file = tex.file, append = TRUE);
		write("\\item remove any variant with VAF $<$ 0.05", file = tex.file, append = TRUE);
		write("\\item keep any variant identified by OncoKB as oncogenic or ", file = tex.file, append = TRUE);
		write("\\item keep any variant identified by OncoKB as Loss-of-function, Likely Loss-of-function, Gain-of-function, Likely Gain-of-function or Switch-of-function", file = tex.file, append = TRUE);
		write("\\end{itemize}\n\\pagebreak\n", file = tex.file, append = TRUE);
		}

	# add per-sample summary (proportion basechange/functional, msi, ...)
	if (any('mutation_summary.png' %in% names(all.plots))) {

		signature.plot <- all.plots['mutation_summary.png'];
		write("\\begin{figure}[h!]", file = tex.file, append = TRUE);
		write("\\begin{center}", file = tex.file, append = TRUE);
		write(paste0(
			"\\includegraphics[height=0.7\\textheight]{",
			signature.plot, '}'
			), file = tex.file, append = TRUE);
		write("\\end{center}", file = tex.file, append = TRUE);
		write(paste0("\\caption{", summary.caption, "}"
			), file = tex.file, append = TRUE);
		write("\\end{figure}\n\\pagebreak\n", file = tex.file, append = TRUE);
		}

	# add recurrence heatmap
	if (any('snv_recurrent_genes.png' %in% names(all.plots))) {
		rec.plot <- all.plots['snv_recurrent_genes.png'];
		write("\\begin{figure}[h!]", file = tex.file, append = TRUE);
		write("\\begin{center}", file = tex.file, append = TRUE);
		write(paste0(
			"\\includegraphics[width=0.95\\textwidth]{", rec.plot, '}'
			), file = tex.file, append = TRUE);
		write("\\end{center}", file = tex.file, append = TRUE);
		write(paste0(
			"\\caption{", recurrence.caption, "}"
			), file = tex.file, append = TRUE);
		write("\\end{figure}\n\\pagebreak\n", file = tex.file, append = TRUE);
		}
	}

### SAVE SESSION INFO ##############################################################################
save.session.profile(generate.filename('RecurrentSNVs','SessionProfile','txt'));
