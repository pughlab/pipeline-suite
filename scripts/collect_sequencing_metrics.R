### collect_sequencing_metrics.R ###################################################################
# Finds and combines output generated by picard/gatk4

### FUNCTIONS ######################################################################################
# function to generate a standardized filename
generate.filename <- function(project.stem, file.core, extension, include.date = TRUE) {

	# build up the filename
	file.name <- paste(project.stem, file.core, sep = '_');
	file.name <- paste(file.name, extension, sep = '.');

	if (include.date) {
		file.name <- paste(Sys.Date(), file.name, sep = '_');
		}

	return(file.name);
	}

# function to write session profile to file
save.session.profile <- function(file.name) {

	# open the file
	sink(file = file.name, split = FALSE);

	# write memory usage to file
	cat('### MEMORY USAGE ###############################################################');
	print(proc.time());

	# write sessionInfo to file
	cat("\n### SESSION INFO ###############################################################");
	print(sessionInfo());

	# close the file
	sink();

	}

### PREPARE SESSION ################################################################################
# import libraries
library(argparse);
library(plyr);

# import command line arguments
parser <- ArgumentParser();

parser$add_argument('-d', '--directory', type = 'character', help = 'path to data directory');
parser$add_argument('-p', '--project', type = 'character', help = 'project name');

arguments <- parser$parse_args();

# what's the date?
date <- Sys.Date();

setwd(arguments$directory);

### MAIN ###########################################################################################
# find results files
bait.bias.files <- list.files(pattern = 'bait_bias_summary_metrics', recursive = TRUE);
pre.adapter.files <- list.files(pattern = 'pre_adapter_summary_metrics', recursive = TRUE);
contamination.files <- list.files(pattern = 'contamination.table$', recursive = TRUE);
gc.bias.files <- list.files(pattern = 'gc_bias_metrics_summary.txt', recursive = TRUE);

alignment.files <- list.files(pattern = 'alignment_metrics.txt', recursive = TRUE);
wgs.files <- list.files(pattern = 'wgs_metrics.txt', recursive = TRUE);
hs.files <- list.files(pattern = 'hs_metrics.txt', recursive = TRUE);
target.files <- list.files(pattern = 'hs_metrics_targetcoverage.txt', recursive = TRUE);

insert.files <- list.files(pattern = 'insert_size.txt', recursive = TRUE);

# read them in
artefact.list <- list();
contamination.list <- list();
gcbias.list <- list();
alignment.list <- list();
wgs.list <- list();
hs.list <- list();
insert.list <- list();

for (file in bait.bias.files) {
	# extract sample ID
	smp <- sub('_artifact_metrics.bait_bias_summary_metrics','',basename(file));
	# store data in list
	tmp <- read.delim(file, comment.char = '#');
	tmp <- tmp[,c('SAMPLE_ALIAS','LIBRARY','REF_BASE','ALT_BASE','TOTAL_QSCORE','ARTIFACT_NAME')];
	tmp$TYPE <- 'bait bias';
	tmp$ID <- smp;
	artefact.list[[smp]] <- tmp;
	}

for (file in pre.adapter.files) {
	# extract sample ID
	smp <- sub('_artifact_metrics.pre_adapter_summary_metrics','',basename(file));
	# store data in list
	tmp <- read.delim(file, comment.char = '#');
	tmp <- tmp[,c('SAMPLE_ALIAS','LIBRARY','REF_BASE','ALT_BASE','TOTAL_QSCORE','ARTIFACT_NAME')];
	tmp$TYPE <- 'pre-adapter';
	tmp$ID <- smp;
	artefact.list[[smp]] <- rbind(artefact.list[[smp]], tmp);
	}

for (file in contamination.files) {
	# extract sample ID
	smp <- sub('_contamination.table','',basename(file));
	# store data in list
	tmp <- read.delim(file, comment.char = '#');
	tmp$ID <- smp;
	contamination.list[[smp]] <- tmp;
	}

for (file in insert.files) {
	# extract sample ID
	smp <- sub('_insert_size.txt','',basename(file));
	# read in data
	tmp <- read.delim(file, skip = 6, nrow = 3);
	tmp$SAMPLE <- smp;
	# store data in list
	insert.list[[smp]] <- tmp[,-which(colnames(tmp) %in% c('LIBRARY','READ_GROUP'))];
	}

for (file in gc.bias.files) {
	# extract sample ID
	smp <- sub('_gc_bias_metrics_summary.txt','',basename(file));
	# store data in list
	tmp <- read.delim(file, comment.char = '#');
	tmp$ID <- smp;
	gcbias.list[[smp]] <- tmp;
	}

for (file in alignment.files) {
	# extract sample ID
	smp <- sub('_alignment_metrics.txt','',basename(file));
	# store data in list
	tmp <- read.delim(file, skip = 6);
	tmp$LEVEL <- apply(
		tmp[,c('SAMPLE','LIBRARY','READ_GROUP')], 1, function(i) {
			i[is.na(i)] <- '';
			if (i[1] == '') { 'ALL_READS' } else if (i[2] == '') { 'SAMPLE'
			} else if (i[3] == '') { 'LIBRARY' } else { 'READ_GROUP' }
			}
		);
	tmp$SAMPLE <- smp;
	alignment.list[[smp]] <- tmp[,c(23,26,1:22,24:25)];
	}

for (file in wgs.files) {
	# extract sample ID
	smp <- sub('_wgs_metrics.txt','',basename(file));
	# read in data
	metrics <- read.delim(file, skip = 6, nrow = 1);
	counts <- read.delim(file, skip = 10);
	colnames(counts)[2] <- smp;
	# store data in list
	wgs.list$metrics[[smp]] <- metrics;
	wgs.list$counts[[smp]] <- counts;
	}

for (file in hs.files) {
	# extract sample ID
	smp <- sub('_hs_metrics.txt','',basename(file));
	# read in data
	metrics <- read.delim(file, skip = 6, nrow = 1);
	counts <- read.delim(file, skip = 10);
	counts$ID <- smp;
	# store data in list
	hs.list$metrics[[smp]] <- metrics;
	hs.list$counts[[smp]] <- counts;
	}

for (file in target.files) {
	# extract sample ID
	smp <- sub('_hs_metrics_targetcoverage.txt','',basename(file));
	# read in data
	metrics <- read.delim(file);
	metrics <- metrics[,c('chrom','start','end','mean_coverage')];
	colnames(metrics)[4] <- smp;
	# store data in list
	hs.list$pertarget[[smp]] <- metrics;
	}

# reshape/format data
artefact.data <- do.call(rbind, artefact.list);
if (any(grepl('fastq', artefact.data$SAMPLE_ALIAS))) {
	colnames(artefact.data)[which(colnames(artefact.data) == 'SAMPLE_ALIAS')] <- 'FASTQ';
	colnames(artefact.data)[which(colnames(artefact.data) == 'ID')] <- 'SAMPLE_ALIAS';
	artefact.data <- artefact.data[,c('SAMPLE_ALIAS','LIBRARY','REF_BASE','ALT_BASE','TOTAL_QSCORE','ARTIFACT_NAME','TYPE','FASTQ')];
	} else {
	artefact.data <- artefact.data[,c('ID','SAMPLE_ALIAS','LIBRARY','REF_BASE','ALT_BASE','TOTAL_QSCORE','ARTIFACT_NAME','TYPE')];
	}

contest.data <- do.call(rbind, contamination.list);
if (any(grepl('fastq', contest.data$sample))) {
	colnames(contest.data)[which(colnames(contest.data) == 'sample')] <- 'FASTQ';
	contest.data$sample <- rownames(contest.data);
	contest.data <- contest.data[,c('sample','contamination','error','FASTQ')];
	} else {
	contest.data <- contest.data[,c('ID','sample','contamination','error')];
	}

metric.data <- do.call(rbind, alignment.list);
gcbias.data <- do.call(rbind, gcbias.list);
insert.data <- do.call(rbind, insert.list);
insert.data <- insert.data[,c('SAMPLE',setdiff(colnames(insert.data),'SAMPLE'))];

# save combined/formatted data to file
if (!is.null(artefact.data)) {
	write.table(
		artefact.data,
		file = generate.filename(arguments$project, 'SequenceArtefacts','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);
	}

if (!is.null(contest.data)) {
	write.table(
		contest.data,
		file = generate.filename(arguments$project, 'ContaminationEstimates','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);
	}

if (!is.null(metric.data)) {
	write.table(
		metric.data,
		file = generate.filename(arguments$project, 'AlignmentMetrics','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);
	}

if (!is.null(gcbias.data)) {
	write.table(
		gcbias.data,
		file = generate.filename(arguments$project, 'GCbiasMetrics','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);
	}

if (!is.null(insert.data)) {
	write.table(
		insert.data,
		file = generate.filename(arguments$project, 'InsertSizes','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		quote = FALSE,
		sep = '\t'
		);
	}

# format WGS metrics if available
if (length(wgs.files) > 0) {

	wgs.metrics <- do.call(rbind, wgs.list$metrics);
	wgs.histogram <- join_all(wgs.list$counts);

	write.table(
		wgs.metrics,
		file = generate.filename(arguments$project, 'WGSMetrics','tsv'),
		row.names = TRUE,
		col.names = NA,
		sep = '\t'
		);

	write.table(
		wgs.histogram,
		file = generate.filename(arguments$project, 'CoverageHistogram','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);
	}

# format HS metrics if available
if (length(hs.files) > 0) {

	hs.metrics <- do.call(rbind, hs.list$metrics);
	hs.histogram <- do.call(rbind, hs.list$counts);

	write.table(
		hs.metrics,
		file = generate.filename(arguments$project, 'HSMetrics','tsv'),
		row.names = TRUE,
		col.names = NA,
		sep = '\t'
		);

	write.table(
		hs.histogram,
		file = generate.filename(arguments$project, 'HShistogram','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);
	}

# format per-target coverage if available
if (length(target.files) > 0) {

	target.cov <- join_all(hs.list$pertarget);

	write.table(
		target.cov,
		file = generate.filename(arguments$project, 'pertarget_coverage','tsv'), 
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);
	}

### SAVE SESSION INFO ##############################################################################
save.session.profile(generate.filename('CollectMetrics','SessionProfile','txt'));
