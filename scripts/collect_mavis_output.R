### collect_mavis_output.R #########################################################################
# Finds and combines output generated by MAVIS.

### FUNCTIONS ######################################################################################
# function to generate a standardized filename
generate.filename <- function(project.stem, file.core, extension, include.date = TRUE) {

	# build up the filename
	file.name <- paste(project.stem, file.core, sep = '_');
	file.name <- paste(file.name, extension, sep = '.');

	if (include.date) {
		file.name <- paste(Sys.Date(), file.name, sep = '_');
		}

	return(file.name);
	}

# function to write session profile to file
save.session.profile <- function(file.name) {

	# open the file
	sink(file = file.name, split = FALSE);

	# write memory usage to file
	cat('### MEMORY USAGE ###############################################################');
	print(proc.time());

	# write sessionInfo to file
	cat("\n### SESSION INFO ###############################################################");
	print(sessionInfo());

	# close the file
	sink();

	}

# function to annotate entrez gene ids by symbol
annotate.with.entrez <- function(hugo_symbols) {
	mapIds(org.Hs.eg.db,
		keys = hugo_symbols,
		column = "ENTREZID",
		keytype = "SYMBOL",
		multiVals = "first"
		);
	}

# function to annotate entrez gene ids by symbol
annotate.with.contig <- function(hugo_symbols) {
	mapIds(org.Hs.eg.db,
		keys = hugo_symbols,
		column = "MAP",
		keytype = "SYMBOL",
		multiVals = "first"
		);
	}

# function to extract read counts
extract.evidence <- function(x) {
	x <- unlist(strsplit(as.character(x),';'));
	if (any(x == 'None')) { x[which(x == 'None')] <- 0; }
	x <- as.numeric(x);
	max(x);
	};

### PREPARE SESSION ################################################################################
# import command line arguments
library(argparse);

parser <- ArgumentParser();

parser$add_argument('-d', '--directory', type = 'character', help = 'path to data directory');
parser$add_argument('-p', '--project', type = 'character', help = 'project name');
parser$add_argument('-t', '--targets', type = 'character', help = 'path to target regions', default = NULL);
parser$add_argument('-g', '--genome', type = 'character', help = 'genome build', default = 'GRCh38');
parser$add_argument('-c', '--center', type = 'character', help = 'data center (for cbioportal annotation)', default = 'PMCC');
parser$add_argument('-f', '--find_drawings', type = 'logical', help = 'find and extract key drawings?', default = FALSE);

arguments <- parser$parse_args();

# what's the date?
date <- Sys.Date();

setwd(arguments$directory);

# import libraries
library(GenomicRanges);
library(plyr);
library(AnnotationDbi);
library(org.Hs.eg.db);


### COLLECT KEY DRAWINGS ###########################################################################
if (arguments$find_drawings) {

	# move to input directory (should be patient directory)
	input.dir <- getwd();
	output.dir <- paste0(input.dir, '/key_drawings');

	# create new folder
	dir.create(output.dir);

	# read in final mavis calls
	mavis.files <- list.files(pattern = 'mavis_summary_all', recursive = TRUE);
	mavis.data <- read.delim(mavis.files[1]);

	keep.figures <- unique(mavis.data$annotation_figure);
	keep.figures <- keep.figures[!grepl('None', keep.figures)];

	# find all svg files
	all.drawings <- list.files(path = input.dir, pattern = '.svg$', recursive = TRUE, full.names = TRUE);

	print(paste('Found', length(all.drawings), 'svg files.'));

	# subset to only final mavis calls
	key.drawings <- intersect(keep.figures, all.drawings);

	print(paste('Found', length(key.drawings), 'svg files also in final MAVIS callset.'));

	# filter drawings (remove any intergenic ones)
	key.drawings <- key.drawings[!grepl('-NA_|_NA.svg', key.drawings)];

	print(paste('  Copying', length(key.drawings), 'gene-gene .svg files to', output.dir, '...'));

	setwd(output.dir);

	for (i in key.drawings) {
		cp.cmd <- paste0('cp ', i, ' .');
		system(cp.cmd);
		}

	write(
		'Copying of gene-gene drawings completed successfully.',
		file = 'find_drawings.COMPLETE'
		);

	} else {

### MAIN ###########################################################################################
	# find results files
	mavis.files <- list.files(pattern = 'mavis_summary_all', recursive = TRUE);

	# read them in
	sv.list <- list();

	for (file in mavis.files) {
		# extract sample ID
		smp <- unlist(strsplit(file, '\\/'))[1];
		# read in and store data in list
		sv.list[[smp]] <- read.delim(file, as.is = TRUE);
		}

	# reshape/format data
	sv.data.full <- join_all(
		sv.list,
		type = 'full',
		match = 'first'
		);
	colnames(sv.data.full)[which(colnames(sv.data.full) == 'X.tracking_id')] <- 'tracking_id';

	key.fields <- c('event_type','gene1_aliases','gene2_aliases','transcript1','transcript2','gene1_direction','gene2_direction','exon_last_5prime','exon_first_3prime','fusion_splicing_pattern','break1_chromosome','break1_position_start','break1_position_end','break2_chromosome','break2_position_start','break2_position_end','break1_split_reads','break2_split_reads','spanning_reads','flanking_pairs','linking_split_reads','library','tracking_id','tools','protocol','call_method');

	smp.fields <- sort(colnames(sv.data.full)[grep('_genome|_transcriptome',colnames(sv.data.full))]);
	smp.fields.names <- sapply(smp.fields, function(i) { unlist(strsplit(i,'_'))[1] } );
	normal.smps <- gsub('\\.','-',smp.fields.names[grepl('normal', smp.fields)]);
	tumour.smps <- gsub('\\.','-',smp.fields.names[grepl('diseased_genome', smp.fields)]);
	rna.smps <- gsub('\\.','-',smp.fields.names[grepl('transcriptome', smp.fields)]);

	sv.data <- sv.data.full[,c(key.fields, smp.fields)];

	# fill in missing tools (custom conversion scripts)
	new.tools <- apply(
		sv.data[,c('tracking_id','tools')],
		1,
		function(i) {

			ids <- unlist(strsplit(as.character(i[1]),';'));
			tools <- setdiff(unlist(strsplit(as.character(i[2]),';')),'');

			if (any(grepl('pindel', ids))) { tools <- c(tools,'pindel'); }
			if (any(grepl('svict', ids))) { tools <- c(tools,'svict'); }
			if (any(grepl('novobreak', ids))) { tools <- c(tools,'novobreak'); }
			if (any(grepl('fusioncatcher', ids))) { tools <- c(tools,'fusioncatcher'); }
			if (any(grepl('arriba', ids))) { tools <- c(tools, 'arriba'); }

			toolset <- paste(na.omit(tools), collapse = ';');
			if (length(tools) > 0) { 
				return(toolset);
				} else {
				return('');
				}
			}
		);

	sv.data$tools <- new.tools;
	sv.data$Fusion <- paste0(sv.data$gene1_aliases,'--',sv.data$gene2_aliases);

	# save combined/formatted data to file
	write.table(
		sv.data,
		file = generate.filename(arguments$project, 'mavis_output','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		sep = '\t'
		);

	# if target regions were provided
	if (!is.null(arguments$targets)) {

		# get target regions
		target_bed <- read.delim(arguments$targets, header = FALSE, comment.char = '#');
		colnames(target_bed)[1:3] <- c('Chromosome','Start','End');

		# create genomic ranges object for target regions
		target.gr <- makeGRangesFromDataFrame(target_bed, starts.in.df.are.0based = TRUE);

		# create genomic ranges object for each breakpoint
		first_bp <- data.frame(
			Chromosome = paste0('chr',sv.data$break1_chromosome),
			Start = sv.data$break1_position_start,
			End = sv.data$break1_position_end
			);

		second_bp <- data.frame(
			Chromosome = paste0('chr',sv.data$break2_chromosome),
			Start = sv.data$break2_position_start,
			End = sv.data$break2_position_end
			);

		bp1.gr <- makeGRangesFromDataFrame(first_bp, starts.in.df.are.0based = FALSE);
		bp2.gr <- makeGRangesFromDataFrame(second_bp, starts.in.df.are.0based = FALSE);

		# find overlaps
		overlaps.p1 <- as.data.frame(findOverlaps(bp1.gr, target.gr));
		overlaps.p2 <- as.data.frame(findOverlaps(bp2.gr, target.gr));

		overlap.data <- merge(
			overlaps.p1,
			overlaps.p2,
			by = 'queryHits',
			suffixes = c('.1','.2'),
			all = TRUE
			);

		# only keep entries for which both breakpoints are within target regions
		to.remove <- which(is.na(overlap.data$subjectHits.1) | is.na(overlap.data$subjectHits.2));
		keep.idx <- c(
			intersect(
				unique(overlap.data[-to.remove,]$queryHits),
				which(sv.data$protocol == 'genome')
				),
			which(sv.data$protocol == 'transcriptome')
			);

		# filter initial input
		sv.data.filtered <- sv.data[keep.idx,];

		# save filtered data
		write.table(
			sv.data.filtered,
			file = generate.filename(arguments$project, 'mavis_output_filtered','tsv'),
			row.names = FALSE,
			col.names = TRUE,
			sep = '\t'
			);

		} else { 
		sv.data.filtered <- sv.data;
		}

	### CBIOPORTAL ######################
	svs <- sv.data.filtered;
	rm(sv.data, sv.data.filtered);

	# extract number of tools
	svs$N.tools <- sapply(svs$tools, function(i) { length(unlist(strsplit(i,';'))) } );

	# extract number of reads
	svs$Evidence <- 0;

	spanning.idx <- grepl('spanning', svs$call_method);
	spanning.counts <- sapply(svs$spanning_reads, extract.evidence);
	if (any(spanning.idx)) {
		svs[which(spanning.idx),]$Evidence <- spanning.counts[which(spanning.idx)];
		}

	flanking.idx <- grepl('flanking', svs$call_method);
	flanking.counts <- sapply(svs$flanking_pairs, extract.evidence);
	if (any(flanking.idx)) {
		svs[which(flanking.idx),]$Evidence <- apply(
			cbind(flanking.counts[which(flanking.idx)],svs[which(flanking.idx),]$Evidence),1,max
			);
		}

	split.idx <- grepl('split', svs$call_method);
	split1.counts <- sapply(svs$break1_split_reads, extract.evidence);
	split2.counts <- sapply(svs$break2_split_reads, extract.evidence);
	linking.counts <- sapply(svs$linking_split_reads, extract.evidence);
	split.counts <- apply(cbind(split1.counts,split2.counts,linking.counts),1,function(i) { 
		min(c(i[1] + i[3], i[2] + i[3])) } );

	if (any(split.idx)) {
		svs[which(split.idx),]$Evidence <- apply(
			cbind(split.counts[which(split.idx)], svs[which(split.idx),]$Evidence),1,max);
		}

	svs <- svs[order(svs$library, svs$tracking_id, -svs$N.tools, -svs$Evidence),];

	# is this a tumour or normal sample?
	svs$Status <- 'somatic';
	if ( (length(normal.smps) > 0) & (any(svs$library %in% normal.smps)) ) {
		svs[which(svs$library %in% normal.smps),]$Status <- 'germline';
		}
	if ( (length(tumour.smps) > 0) & (length(normal.smps) > 1) ) {
		germ.idx <- which(apply(
			svs[,names(normal.smps)],1,function(i) { any(i == 'germline', na.rm = TRUE) } ));
		svs[germ.idx,]$Status <- 'germline';
		}

	# get type of evidence (DNA or RNA)
	svs[,c('DNA_Support','RNA_Support')] <- 'No';
	if (any(svs$protocol == 'genome')) {
		svs[which(svs$protocol == 'genome'),]$DNA_Support <- 'Yes';
		}

	if (length(rna.smps) > 0) {
		svs[which(svs$protocol == 'transcriptome'),]$RNA_Support <- 'Yes';

		# do any of these support DNA-based events?
		rna.idx <- if (length(rna.smps) > 1) {
			which(apply(svs[,names(rna.smps)],1,function(i) { any(i == 'expressed', na.rm = TRUE) } ));
			} else {
			which(sapply(svs[,names(rna.smps)],function(i) { any(i == 'expressed', na.rm = TRUE) } ));
			}
		if (length(rna.idx) > 0) { svs[rna.idx,]$RNA_Support <- 'Yes'; }
		}

	# do any DNA entries support RNA-based events?
	if (length(tumour.smps) > 0) {
		dna.idx <- if (length(tumour.smps) > 1) {
			which(apply(svs[,names(tumour.smps)],1,function(i) { any(i == 'genomic support', na.rm = TRUE) } ));
			} else {
			which(sapply(svs[,names(tumour.smps)],function(i) { any(i == 'genomic support', na.rm = TRUE) } ));
			}
		if (length(dna.idx) > 0) { svs[dna.idx,]$DNA_Support <- 'Yes'; }
		}

	# is this an inframe or frameshift variant?
	svs$Frame <- 'unknown';
	if (any(svs$fusion_splicing_pattern == 'normal')) {
		svs[which(svs$fusion_splicing_pattern == 'normal'),]$Frame <- 'inframe';
		}
	if (any(!svs$fusion_splicing_pattern %in% c('normal','None'))) {
		svs[which(!svs$fusion_splicing_pattern %in% c('normal','None')),]$Frame <- 'frameshift';
		}

	### RECURRENCE FILTER ##############################################################################
	# add quick recurrence filter (likely false positives/artefacts)
	if (length(normal.smps) > 0) {
		germline.recurrence <- aggregate(
			library ~ break1_chromosome + break1_position_start + break1_position_end + break2_chromosome + break2_position_start + break2_position_end + event_type,
			svs[which(svs$library %in% normal.smps),],
			length
			);
		colnames(germline.recurrence)[ncol(germline.recurrence)] <- 'NormalCount';

		recurrence.data <- germline.recurrence;
		}

	if (length(tumour.smps) > 0) {
		somatic.recurrence <- aggregate(
			library ~ break1_chromosome + break1_position_start + break1_position_end + break2_chromosome + break2_position_start + break2_position_end + event_type,
			svs[which(svs$library %in% tumour.smps & svs$Status == 'somatic'),],
			length
			);
		colnames(somatic.recurrence)[ncol(somatic.recurrence)] <- 'TumourCount';

		if (exists('recurrence.data')) {
			recurrence.data <- merge(germline.recurrence,somatic.recurrence,all = TRUE);
			} else {
			recurrence.data <- somatic.recurrence;
			}
		}

	if (length(rna.smps) > 0) {
		rna.recurrence <- aggregate(
			library ~ break1_chromosome + break1_position_start + break1_position_end + break2_chromosome + break2_position_start + break2_position_end + event_type,
			svs[which(svs$library %in% rna.smps & svs$Status == 'somatic'),],
			length
			);
		colnames(rna.recurrence)[ncol(rna.recurrence)] <- 'RNACount';

		if (exists('recurrence.data')) {
			recurrence.data <- merge(recurrence.data, rna.recurrence, all = TRUE);
			} else {
			recurrence.data <- rna.recurrence;
			}
		}

	# define thresholds
	germline.threshold <- min(if (length(normal.smps) == 1) { 1 } else { length(normal.smps)*0.5 }, 5);
	somatic.threshold <- if (length(tumour.smps) == 1) { 1 } else { length(tumour.smps)*0.8 }
	rna.threshold <- if (length(rna.smps) == 1) { 1 } else { length(rna.smps)*0.8 }

	tmp <- merge(svs, recurrence.data, all.x = TRUE);
	to.remove <- unique(c(
		which(tmp$NormalCount > germline.threshold), # dont specify germline in case of t-only cases
		which(tmp$Status == 'somatic' & tmp$TumourCount > somatic.threshold),
		which(tmp$protocol == 'transcriptome' & tmp$RNACount > rna.threshold)
		));

	print(paste0('Removing ', length(to.remove), ' (', round(length(to.remove)/nrow(svs)*100),
		'%) SVs for high breakpoint recurrence.'));

	if (length(to.remove) > 0) {
		filtered.svs <- tmp[-to.remove,colnames(svs)];
		} else {
		filtered.svs <- tmp[,colnames(svs)];
		}

	### SIZE FILTER ####################################################################################
	# remove short INDELs (< 100bp) and inversions
	filtered.svs$Length <- abs(filtered.svs$break2_position_start - filtered.svs$break1_position_start);
	inter.chrom <- which(filtered.svs$break1_chromosome != filtered.svs$break2_chromosome);
	if (length(inter.chrom) > 0) { filtered.svs[inter.chrom,]$Length <- NA; }

	short.idx <- which(
		filtered.svs$event_type %in% c('deletion','insertion','duplication','inversion') &
		filtered.svs$Length < 100
		);

	print(paste0('Removing ', length(short.idx), ' (', round(length(short.idx)/nrow(filtered.svs)*100),
		'%) short DEL/INS/DUP/INV (<100bp).'));

	if (length(short.idx) > 0) {
		filtered.svs <- filtered.svs[-c(short.idx),];
		}

	# format for cBioportal
	cbio.svs <- data.frame(
		Sample_Id = filtered.svs$library,
		SV_Status = toupper(filtered.svs$Status),
		Site1_Hugo_Symbol = filtered.svs$gene1_aliases,
		Site1_Entrez_Gene_Id = annotate.with.entrez(filtered.svs$gene1_aliases),
		Site1_Ensembl_Transcript_Id = filtered.svs$transcript1,
		Site1_Region_Number = NA, #filtered.svs$exon_last_5prime,
		Site1_Region = NA, #(5_Prime_UTR,3_Prime_UTR,Promoter,Exon,Intron)
		Site1_Chromosome = filtered.svs$break1_chromosome,
		Site1_Contig = annotate.with.contig(filtered.svs$gene1_aliases),
		Site1_Position = filtered.svs$break1_position_start,
		Site1_Description = NA,
		Site2_Hugo_Symbol = filtered.svs$gene2_aliases,
		Site2_Entrez_Gene_Id = annotate.with.entrez(filtered.svs$gene2_aliases),
		Site2_Ensembl_Transcript_Id = filtered.svs$transcript2,
		Site2_Region_Number = NA, #filtered.svs$exon_first_3prime,
		Site2_Region = NA,
		Site2_Chromosome = filtered.svs$break2_chromosome,
		Site2_Contig = annotate.with.contig(filtered.svs$gene2_aliases),
		Site2_Position = filtered.svs$break2_position_start,
		Site2_Description = NA,
		Site2_Effect_On_Frame = c('In_frame','Frameshift','Frameshift',NA)[match(
			# in_frame, frameshift, out-of-frame
			filtered.svs$fusion_splicing_pattern,
			c('normal','retained intron','skipped exon','None'))],
		NCBI_Build = rep(arguments$genome,nrow(filtered.svs)),
		Class = c('Deletion','Duplication','Insertion','Inversion','Translocation','Translocation')[match(
			filtered.svs$event_type,
			c('deletion','duplication','insertion','inversion','translocation','inverted translocation'))],
		Tumor_Split_Read_Count = NA,
		Tumor_Paired_End_Read_Count = NA,
		Event_Info = NA, 
		Connection_Type = paste0(filtered.svs$gene1_direction,'to',filtered.svs$gene2_direction),
		Breakpoint_Type = apply(filtered.svs[,c('break1_position_start','break1_position_end','break2_position_start','break2_position_end')],
			1, function(i) { if (sum(c(i[2] - i[1], i[4]-i[3])) > 0) { 'IMPRECISE' } else { 'PRECISE' } }), 
		Annotation = NA,
		DNA_Support = filtered.svs$DNA_Support,
		RNA_Support = filtered.svs$RNA_Support,
		SV_Length = filtered.svs$Length,
		Normal_Read_Count = NA,
		Tumor_Read_Count = NA,
		Normal_Paired_End_Read_Count = NA,
		Normal_Split_Read_Count = NA,
		Comments = NA,
		Fusion = paste0(filtered.svs$gene1_aliases, '--', filtered.svs$gene2_aliases),
		Site1_Split_Read_Count = sapply(filtered.svs$break1_split_reads, extract.evidence),
		Site2_Split_Read_Count = sapply(filtered.svs$break2_split_reads, extract.evidence),
		Linking_Split_Reads = sapply(filtered.svs$linking_split_reads, extract.evidence),
		Spanning_Reads = sapply(filtered.svs$spanning_reads, extract.evidence),
		Flanking_Read_Pairs = sapply(filtered.svs$flanking_pairs, extract.evidence),
		Tools = filtered.svs$tools,
		Total_Evidence = filtered.svs$Evidence
		);

	# clean up regions
	if (arguments$genome %in% c('hg19','GRCh37')) {
		library('TxDb.Hsapiens.UCSC.hg19.knownGene');
		txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene;

		} else if (arguments$genome %in% c('hg38','GRCh38')) {
		library('TxDb.Hsapiens.UCSC.hg38.knownGene');
		txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene;

		} else {
		stop('Unknown reference provided; must be one of hg19 or hg38.');
		}

	gene.gr <- transcriptsBy(txdb, by = 'gene');

	gene.ids <- names(gene.gr);
	exon.data <- select(txdb,
		keys = gene.ids,
		keytype = 'GENEID',
		columns = c('TXNAME','TXCHROM','TXSTRAND','TXSTART','TXEND','EXONRANK','EXONSTART','EXONEND')
		);

	exon.data$REGION <- 'EXON';

	# estimate promoter region
	tss.data <- aggregate(TXSTART ~ TXNAME + TXCHROM + TXSTRAND, exon.data[which(exon.data$TXSTRAND == '+'),], min);
	colnames(tss.data)[4] <- 'TSS';
	tss.data$PROMOTER <- tss.data$TSS - 1000;
	tmp <- aggregate(TXEND ~ TXNAME + TXCHROM + TXSTRAND, exon.data[which(exon.data$TXSTRAND == '-'),], max);
	colnames(tmp)[4] <- 'TSS';
	tmp$PROMOTER <- tmp$TSS + 1000;
	tss.data <- rbind(tss.data, tmp);
	rm(tmp);

	tss.data$EXONSTART <- apply(tss.data[,c('TSS','PROMOTER')],1,min);
	tss.data$EXONEND <- apply(tss.data[,c('TSS','PROMOTER')],1,max);
	tss.data$REGION <- 'PROMOTER';

	gene.data <- merge(exon.data, tss.data[,c('TXNAME','TXCHROM','TXSTRAND','EXONSTART','EXONEND','REGION')], all = TRUE);
	gene.data <- gene.data[order(gene.data$TXCHROM, gene.data$EXONSTART, gene.data$EXONEND),];

	rm(txdb, gene.gr, gene.ids, exon.data, tss.data);

	# annotate breakpoints
	site1_bp <- data.frame(
		Chromosome = paste0('chr',cbio.svs$Site1_Chromosome),
		Start = cbio.svs$Site1_Position,
		End = cbio.svs$Site1_Position
		);
	site2_bp <- data.frame(
		Chromosome = paste0('chr',cbio.svs$Site2_Chromosome),
		Start = cbio.svs$Site2_Position,
		End = cbio.svs$Site2_Position
		);

	bp1.gr <- makeGRangesFromDataFrame(site1_bp, starts.in.df.are.0based = FALSE);
	bp2.gr <- makeGRangesFromDataFrame(site2_bp, starts.in.df.are.0based = FALSE);

	gene.gr <- makeGRangesFromDataFrame(gene.data,
		seqnames.field = 'TXCHROM',
		start.field = 'EXONSTART',
		end.field = 'EXONEND',
		strand.field = 'TXSTRAND'
		);

	# find overlaps
	overlap.bp1 <- as.data.frame(findOverlaps(bp1.gr, gene.gr));
	overlap.bp2 <- as.data.frame(findOverlaps(bp2.gr, gene.gr));

	# fill in results (EXON or PROMOTER hits)
	for (i in unique(overlap.bp1$queryHits)) {
		anno.data <- gene.data[overlap.bp1[which(overlap.bp1$queryHits == i),]$subjectHits,];
		anno.data <- anno.data[grep(cbio.svs[i,]$Site1_Ensembl_Transcript_Id, anno.data$TXNAME),];
		if (nrow(anno.data) == 1) {
			cbio.svs[i,]$Site1_Region <- anno.data$REGION;
			cbio.svs[i,]$Site1_Region_Number <- anno.data$EXONRANK;
			}
		}

	for (i in unique(overlap.bp2$queryHits)) {
		anno.data <- gene.data[overlap.bp2[which(overlap.bp2$queryHits == i),]$subjectHits,];
		anno.data <- anno.data[grep(cbio.svs[i,]$Site2_Ensembl_Transcript_Id, anno.data$TXNAME),];
		if (nrow(anno.data) == 1) {
			cbio.svs[i,]$Site2_Region <- anno.data$REGION;
			cbio.svs[i,]$Site2_Region_Number <- anno.data$EXONRANK;
			}
		}

	# fill in intronic regions (assuming if breakpoint is within a gene, but not in the promoter/exon region)
	cbio.svs[which(grepl('ENST', cbio.svs$Site1_Ensembl_Transcript_Id) & is.na(cbio.svs$Site1_Region)),]$Site1_Region <- 'INTRON';
	cbio.svs[which(grepl('ENST', cbio.svs$Site2_Ensembl_Transcript_Id) & is.na(cbio.svs$Site2_Region)),]$Site2_Region <- 'INTRON';

	# clean up connection type
	cbio.svs$Connection_Type <- factor(cbio.svs$Connection_Type,
		levels = c('5to3','3to5','5to5','3to3')
		);

	# save to file
	write.table(
		cbio.svs,
		file = generate.filename(arguments$project, 'sv_data_formatted','tsv'),
		row.names = FALSE,
		col.names = TRUE,
		quote = FALSE,
		sep = '\t'
		);

	# do some extra filtering for cBioportal
	to.remove <- unique(c(
		# remove germline
		which(cbio.svs$SV_Status == 'GERMLINE'),
		# remove low evidence calls
		which( !grepl(';', cbio.svs$Tools) & cbio.svs$Total_Evidence < 20)
		));

	for.cbio <- cbio.svs[-to.remove,];

	# unless this is germline-only, set up for cbioportal
	if (nrow(for.cbio) > 0) {

		# remove duplicates
		for.cbio$BP1 <- round(for.cbio$Site1_Position/1000,0);
		for.cbio$BP2 <- round(for.cbio$Site2_Position/1000,0);

		for.cbio <- for.cbio[order(for.cbio$Sample_Id, for.cbio$Fusion, -for.cbio$Total_Evidence),];
		for.cbio <- for.cbio[!duplicated(for.cbio[,c('Sample_Id','Site1_Chromosome','BP1','Site2_Chromosome','BP2','Class','Fusion')]),];	

		if (any(grepl('rna', for.cbio$Sample_Id))) {
			for.cbio$ID <- gsub('-rna','',for.cbio$Sample_Id);
			for.cbio <- for.cbio[order(for.cbio$ID, for.cbio$Fusion, for.cbio$Class),];
			}

		# save to file
		write.table(
			for.cbio[,1:37],
			file = generate.filename(arguments$project, 'sv_data_for_cbioportal','tsv'),
			row.names = FALSE,
			col.names = TRUE,
			quote = FALSE,
			sep = '\t'
			);
		}

	### SAVE SESSION INFO ##############################################################################
	save.session.profile(generate.filename('CollectMAVIS','SessionProfile','txt'));
	}
