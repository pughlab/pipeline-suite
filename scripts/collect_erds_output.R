### collect_sequenza_output.R ######################################################################
# Finds and combines output generated by Sequenza (CN segments, cellularity, ploidy)

### FUNCTIONS ######################################################################################
# function to generate a standardized filename
generate.filename <- function(project.stem, file.core, extension, include.date = TRUE) {

	# build up the filename
	file.name <- paste(project.stem, file.core, sep = '_');
	file.name <- paste(file.name, extension, sep = '.');

	if (include.date) {
		file.name <- paste(Sys.Date(), file.name, sep = '_');
		}

	return(file.name);
	}

# function to write session profile to file
save.session.profile <- function(file.name) {

	# open the file
	sink(file = file.name, split = FALSE);

	# write memory usage to file
	cat('### MEMORY USAGE ###############################################################');
	print(proc.time());

	# write sessionInfo to file
	cat("\n### SESSION INFO ###############################################################");
	print(sessionInfo());

	# close the file
	sink();

	}

### PREPARE SESSION ################################################################################
# import libraries
#library(GenomicRanges);
library(org.Hs.eg.db);
library(argparse);

# import command line arguments
parser <- ArgumentParser();

parser$add_argument('-d', '--directory', type = 'character', help = 'path to data directory');
parser$add_argument('-p', '--project', type = 'character', help = 'project name');
parser$add_argument('-r', '--ref_type', type = 'character', help = 'reference type', default = 'hg38');
parser$add_argument('-t', '--targets', type = 'character', help = 'target intervals');

arguments <- parser$parse_args();

# what's the date?
date <- Sys.Date();

setwd(arguments$directory);

### FORMAT ANNOTATION ##############################################################################
if (arguments$ref_type %in% c('hg38','GRCh38')) {
	library(TxDb.Hsapiens.UCSC.hg38.knownGene);
	txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene;
	} else if (arguments$ref_type %in% c('hg19','GRCh37')) {
	library(TxDb.Hsapiens.UCSC.hg19.knownGene);
	txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene;
	}
 
# extract gene positions and annotations
gene.positions <- data.frame(genes(txdb));
gene.annotations <- select(
	org.Hs.eg.db,
	keys = gene.positions$gene_id,
	keytype = 'ENTREZID',
	columns = c('SYMBOL','GENETYPE')
	);

gene.data <- merge(gene.annotations,gene.positions,by.y = 'gene_id', by.x = 'ENTREZID');
gene.data$seqnames <- factor(gene.data$seqnames, levels = paste0('chr',c(1:22,'X','Y')));
gene.data <- gene.data[!is.na(gene.data$seqnames),1:6];
gene.data <- gene.data[!is.na(gene.data$SYMBOL),];
gene.data <- gene.data[order(gene.data$seqnames, gene.data$start),];

gene.gr <- GRanges(gene.data);

colnames(gene.data)[which(colnames(gene.data) == 'seqnames')] <- 'Chromosome';
colnames(gene.data)[which(colnames(gene.data) == 'start')] <- 'Start';
colnames(gene.data)[which(colnames(gene.data) == 'end')] <- 'End';

### MAIN ###########################################################################################
# find results files
cn.files <- list.files(pattern = 'erds.vcf$', recursive = TRUE);

# read them in
cn.list <- list();

for (file in cn.files) {
	# extract sample ID
	smp <- unlist(strsplit(file,'\\/'))[2];
	# store data in list
	tmp <- read.delim(file, as.is = TRUE, comment.char = '#', header = FALSE);
	colnames(tmp) <- c('chrom','start','id','ref','alt','qual','filter','info','format','sample');
	tmp$end <- sapply(tmp$info, function(i) { 
		parts <- unlist(strsplit(as.character(i),';'));
		gsub('END=','',parts[grepl('END=',parts)]);
		} );
	tmp$QA <- sapply(tmp$info, function(i) {
		if (grepl('IMPRECISE', i)) { 'IMPRECISE'; } else { 'PRECISE'; }
		} );
	tmp$CN <- apply(tmp[,c('format','sample')], 1, function(i) {
		idx <- which(unlist(strsplit(i[1],':')) == 'CN');
		cn <- unlist(strsplit(i[2],':'))[idx];
		return(cn);
		} );
	cn.list[[smp]] <- tmp[,c('chrom','start','end','QA','CN')];
	cn.list[[smp]]$ID <- smp;
	rm(tmp);
	}

cn.data <- do.call(rbind, cn.list);
cn.data$CN <- as.numeric(cn.data$CN);
cn.data$end <- as.numeric(cn.data$end);

write.table(
	cn.data[,c('ID','chrom','start','end','CN')],
	file = generate.filename(arguments$project, 'erds_cnv_data','tsv'),
	row.names = FALSE,
	col.names = TRUE,
	sep = '\t'
	);

seg.gr <- GRanges(cn.data);
y <- mergeByOverlaps(seg.gr, gene.gr, minoverlap = 500, type = 'any', select = 'all', maxgap = -1);
tmp <- data.frame(y[['gene.gr']], y[['seg.gr']]);
colnames(tmp)[1:5] <- paste0('gene.',colnames(tmp)[1:5]);
colnames(tmp)[grep('\\.', colnames(tmp))] <- paste0('seg.',
	gsub('\\.1','', colnames(tmp)[grep('\\.', colnames(tmp))])
	);

get.cn <- function(i) {
	j <- max(i)-2;
	return(min(j,4));
	}

pergene.data <- aggregate(CN ~ SYMBOL + ENTREZID + ID, tmp, get.cn);

gene.by.patient <- reshape(
	pergene.data,
	direction = 'wide',
	timevar = 'ID',
	idvar = c('SYMBOL','ENTREZID')
	);
colnames(gene.by.patient) <- gsub('CN.','',colnames(gene.by.patient));

cn.data.annotated <- merge(
	gene.annotation,
	gene.by.patient,
	all.y = TRUE
	);

cn.data.annotated$SYMBOL <- factor(
	cn.data.annotated$SYMBOL,
	levels = as.character(gene.annotation$SYMBOL)
	);

write.table(
	cn.data.annotated[order(cn.data.annotated$SYMBOL),],
	file = generate.filename(arguments$project, 'erds_cnv_annotated','tsv'),
	row.names = FALSE,
	col.names = TRUE,
	sep = '\t'
	);

### SAVE SESSION INFO ##############################################################################
save.session.profile(generate.filename('CollectCNAs','SessionProfile','txt'));
